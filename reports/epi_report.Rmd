---
title: "`r if(exists('params') && !is.null(params$country_code)) { switch(params$country_code, 'syria' = 'IMC Syria Health Surveillance Report', 'yemen' = 'IMC Yemen Health Surveillance Report', 'south_sudan' = 'IMC South Sudan Health Surveillance Report', 'synthetic' = 'Health Surveillance Report', 'Multi-Country Health Surveillance Report') } else 'Health Surveillance Report'`"
subtitle: "`r if(exists('summary_vars') && !is.null(summary_vars$date_range_text)) paste('Reporting Period:', summary_vars$date_range_text) else 'Health Consultations Analysis'`"
author: "`r if(exists('params') && !is.null(params$country_code)) { switch(params$country_code, 'syria' = 'International Medical Corps - Syria Program', 'yemen' = 'International Medical Corps - Yemen', 'south_sudan' = 'International Medical Corps - South Sudan Program', 'synthetic' = 'Synthetic Data', 'Multi-Country Health Program') } else 'Health Surveillance Program'`"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    theme: cosmo
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    fig_width: 12
    fig_height: 7
    df_print: paged
    css: |
      .main-container { max-width: 1200px; margin: auto; }
      .executive-summary { background: #f8f9fa; padding: 20px; border-left: 5px solid #007bff; margin: 20px 0; border-radius: 8px; }
      .key-metrics { display: flex; justify-content: space-around; margin: 20px 0; flex-wrap: wrap; gap: 10px; }
      .metric-box { text-align: center; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin: 5px; min-width: 150px; border: 1px solid #e9ecef; }
      .metric-number { font-size: 24px; font-weight: bold; color: #007bff; margin-bottom: 5px; }
      .metric-label { font-size: 12px; color: #6c757d; text-transform: uppercase; }
      .alert-high { color: #dc3545; font-weight: bold; }
      .alert-medium { color: #fd7e14; font-weight: bold; }
      .alert-low { color: #28a745; font-weight: bold; }
      .ai-enhanced { background: #e3f2fd; padding: 15px; border-radius: 6px; border-left: 4px solid #6366f1; margin: 10px 0; }
      .standard-analysis { background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 3px solid #6c757d; margin: 10px 0; }
      h1 { color: #2c3e50; border-bottom: 2px solid #007bff; padding-bottom: 8px; }
      h2 { color: #34495e; border-bottom: 1px solid #6c757d; padding-bottom: 5px; }
params:
  config_env: "default"
  force_refresh: true
  start_year: 2024
  target_year: !r lubridate::year(Sys.Date())
  enable_ai: true
  date_range_months: 12
  country_code: "synthetic"  # Options: syria, yemen, south_sudan, synthetic
editor_options: 
  markdown: 
    wrap: 72
---

# Setup
- Load packages, config, and modules
- Load data
- ICD-11 Disease Mapping Quality Control (not available with synthetic data)
- Machine Learning Disease Mapping (not available with synthetic data)
- Org Unit Metadata Maintenance (not available with synthetic data)
- Calculate summary variables
- Initialize AI system (if configured)

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = FALSE,  # Disable caching to avoid issues
  fig.align = "center",
  dpi = 300,
  out.width = "100%",
  error = TRUE  # Continue on errors
)


# Optional: auto-install dependencies for report rendering (guarded by env/config)
auto_install <- function() {
  allow <- tolower(Sys.getenv("AUTO_INSTALL_DEPS", "false")) %in% c("1","true","yes")
  if (!allow) {
    # Try config flag quickly
    cfg_file <- NULL
    for (p in c(here::here("config","config.yml"), "config/config.yml", here::here("config.yml"), "config.yml")) {
      if (file.exists(p)) { cfg_file <- p; break }
    }
    if (!is.null(cfg_file)) {
      try({
        yc <- yaml::read_yaml(cfg_file)
        def <- yc[[Sys.getenv("R_CONFIG_ACTIVE", "default")]] %||% yc[["default"]]
        allow <- isTRUE(def$setup$auto_install_deps)
      }, silent = TRUE)
    }
  }
  if (allow) {
    inst <- file.path(getwd(), "scripts", "install_requirements.R")
    if (file.exists(inst)) try(source(inst), silent = FALSE)
  }
}
auto_install()


# Enhanced library loading with error handling
load_packages <- function(packages) {
  missing_packages <- c()
  
  for (pkg in packages) {
    if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
      missing_packages <- c(missing_packages, pkg)
    }
  }
  
  if (length(missing_packages) > 0) {
    cat("⚠️ Missing packages:", paste(missing_packages, collapse = ", "), "\n")
    cat("Run: install.packages(c(", paste0("'", missing_packages, "'", collapse = ", "), "))\n")
  }
  
  return(length(missing_packages) == 0)
}

# Core packages
core_packages <- c(
  "tidyverse", "dplyr", "tidyr", "ggplot2", "scales", "viridis",
  "RColorBrewer", "here", "lubridate", "DT", "plotly", "knitr",
  "flextable", "gtsummary", "purrr", "stringr", "forcats", "tibble",
  "tidyverse", "gtsummary", "treemapify", "leaflet", "ggforce", "sf", "patchwork",
  "ggrepel"
)


# Load packages
packages_loaded <- load_packages(core_packages)

if (!packages_loaded) {
  stop("Required packages missing. Please install them before continuing.")
}

# Safe config loading function (specific to R markdown - avoids conflicts with R modules)
safe_load_config_rmd <- function(config_env = "default") {
  config_loaded <- FALSE
  cfg <- NULL
  
  tryCatch({
    # Only load config package when we actually need it
    if (!requireNamespace("config", quietly = TRUE)) {
      cat("⚠️ config package not available\n")
      return(list(success = FALSE, config = NULL))
    }
    
    library(config, quietly = TRUE)
    
    # Try multiple config file locations
    config_paths <- c(
      here::here("config", "config.yml"),
      here::here("config.yml"),
      "config/config.yml",
      "config.yml"
    )
    
    config_file <- NULL
    for (path in config_paths) {
      if (file.exists(path)) {
        config_file <- path
        break
      }
    }
    
    if (is.null(config_file)) {
      cat("⚠️ No config file found\n")
      return(list(success = FALSE, config = NULL))
    }
    
    cfg <- config::get(
      config = config_env,
      file = config_file,
      use_parent = FALSE
    )
    
    config_loaded <- TRUE
    cat("✅ Config loaded from:", config_file, "\n")
    
  }, error = function(e) {
    cat("⚠️ Config loading failed:", e$message, "\n")
    config_loaded <<- FALSE
  })
  
  return(list(success = config_loaded, config = cfg))
}

# Global theme and colors
theme_set(theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 11),
    legend.title = element_text(size = 11),
    strip.text = element_text(size = 10, face = "bold")
  ))

# Consistent color palette
epi_colors <- c(
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
)

# AI colors for enhanced reports
ai_colors <- list(
  primary = "#1f77b4",
  secondary = "#ff7f0e", 
  success = "#2ca02c",
  danger = "#d62728",
  warning = "#ff6f00",
  info = "#17becf",
  muted = "#666666"
)

# Safe null coalescing and date parser (global)
if (!exists("%||%")) {
  `%||%` <- function(x, y) if (is.null(x) || length(x) == 0) y else x
}

if (!exists("theme_ai_report")) {
  theme_ai_report <- function() ggplot2::theme_minimal()
}

# Load visualization helpers globally 
tryCatch({
  source(here::here("R", "visualization_helpers.R"))
  cat("✅ Visualization helpers loaded successfully\n")
}, error = function(e) {
  cat("⚠️ Could not load visualization_helpers.R:", e$message, "\n")
})

```

```{r epione-branding, results='asis', echo=FALSE}
logo_path <- "app/www/epione_logo.png"
if (file.exists(logo_path)) {
  country_label <- if (exists("params") && !is.null(params$country_code)) {
    if (!is.null(params$country_name)) {
      params$country_name
    } else {
      switch(params$country_code,
             "synthetic" = "Synthetic Dataset",
             toupper(params$country_code))
    }
  } else {
    "Health Program"
  }
  cat(
    '<div style="display:flex;align-items:center;gap:16px;margin:25px 0;">',
    sprintf('<img src="%s" alt="EpiOne logo" style="height:72px;background:#fff;border-radius:8px;padding:6px 10px;box-shadow:0 2px 6px rgba(0,0,0,0.15);"/>', logo_path),
    '<div>',
    '<h1 style="margin:0;">EpiOne Epidemiological Surveillance Report</h1>',
    sprintf('<h3 style="margin:0;font-weight:400;color:#555;">%s — %s</h3>', country_label, format(Sys.Date(), "%B %Y")),
    '</div></div>',
    sep = '\n'
  )
}

cat("✅ Enhanced setup completed successfully\n")
```

```{r inline-helpers, include=FALSE}
val <- function(x, default = "—") if (!is.null(x)) x else default
vget <- function(name, default = "—") { o <- get0(name, ifnotfound = NULL); if (is.null(o)) default else o }
vnrow <- function(x) if (is.null(x)) 0L else nrow(x)
fmt_comma <- function(x, default = "0") { if (is.null(x) || is.na(x)) return(default); scales::comma(x) }
fmt_pct1 <- function(x, default = "0") { if (is.null(x) || is.na(x)) return(default); as.character(round(x, 1)) }
```

```{r load-modules, include=FALSE}

# Safe module loading function
load_module_safe <- function(module_path, required = FALSE, description = NULL) {
  full_path <- here(module_path)

  if (file.exists(full_path)) {
    tryCatch({
      # IMPORTANT: load into the global environment so functions are visible
      source(full_path, local = .GlobalEnv)

      cat("✅ Loaded:", module_path,
          if (!is.null(description)) paste0(" (", description, ")") else "", "\n")
      TRUE
    }, error = function(e) {
      cat("❌ Failed to load", module_path, ":", e$message, "\n")
      if (required) stop("Required module failed to load: ", module_path)
      FALSE
    })
  } else {
    cat(if (required) "❌" else "⚠️", " Module not found:", module_path, "\n")
    if (required) stop("Required module not found: ", module_path)
    FALSE
  }
}

# Essential utilities

# Core modules - prioritize country data loader
modules_loaded <- list(
  country_data_loader = load_module_safe("R/data_loaders/country_data_loader.R", description = "Multi-country data loader"),
  preprocessing = load_module_safe("R/preprocessing.R", description = "Data preprocessing"),
  visualization = load_module_safe("R/visualization_helpers.R", description = "Visualization helpers"),
  disease_categories = load_module_safe("R/disease_categories_taxaware.R", description = "Disease classification"),
  summary_functions = load_module_safe("R/summary_functions.R", description = "Summary functions"),
  validation = load_module_safe("R/validation_rules.R", description = "Data validation"),
  legacy_data_loader = load_module_safe("R/data_loader.R", description = "Legacy Syria data loader")
)

# AI modules (optional)
ai_modules_loaded <- list(
  enhanced_ai = load_module_safe("R/enhanced_ai.R", description = "Enhanced AI analysis"),
  ai_config = load_module_safe("modules/ai_config.R", description = "AI configuration")
  
)

# Create fallback functions for missing modules
create_fallback_function <- function(func_name, return_value = NULL, message = NULL) {
  if (!exists(func_name)) {
    assign(func_name, function(...) {
      if (!is.null(message)) cat(message, "\n")
      return(return_value)
    }, envir = .GlobalEnv)
  }
}

# Essential fallback functions
create_fallback_function("get_epidemic_groups", 
  return_value = list(), 
  message = "⚠️ Epidemic disease definitions not available")

create_fallback_function("validate_register_data", 
  return_value = list(valid = TRUE, warnings = character(0)))

create_fallback_function("generate_basic_epidemic_alerts", 
  return_value = "Alert generation not available")


cat("📦 Module loading completed\n")
cat("📊 Core modules:", sum(unlist(modules_loaded)), "/", length(modules_loaded), "loaded\n")
cat("🤖 AI modules:", sum(unlist(ai_modules_loaded)), "/", length(ai_modules_loaded), "loaded\n")



```


```{r data-loading, echo=FALSE, include=FALSE}
# Flexible data loading that adapts to any country configuration
cat("=== FLEXIBLE DATA LOADING ===\n")

# Get country code from parameters (no hardcoded defaults)
country_code <- params$country_code
config_env <- params$config_env %||% "default"

cat("📊 Loading data for country:", country_code %||% "[not specified]", "\n")
cat("⚙️ Using config environment:", config_env, "\n")

# Load synthetic generator if available
syn_file <- here::here("R", "synthetic_data.R")
if (file.exists(syn_file)) try(source(syn_file), silent = TRUE)

# Helper to check config flag for synthetic
synthetic_enabled_cfg <- FALSE
cfg_attempt <- safe_load_config_rmd(config_env)
if (isTRUE(cfg_attempt$success) && !is.null(cfg_attempt$config)) {
  cfg <- cfg_attempt$config
  synthetic_enabled_cfg <- isTRUE(cfg$testing$use_synthetic_data)
}

# Simple, flexible data loading approach
data_result <- tryCatch({
  register <- NULL

  # Synthetic mode via param or config
  if (tolower(country_code %||% "") == "synthetic" && exists("generate_synthetic_register")) {
    cat("🧪 Using synthetic data generator (param)\n")
    args <- if (exists("resolve_synthetic_args")) resolve_synthetic_args(cfg %||% list(testing = list(synthetic = list()))) else list()
    if (length(args) == 0) args <- list(n = 5000, months = 12, country = "syria", facilities = 60)
    register <- do.call(generate_synthetic_register, args)

  } else if (synthetic_enabled_cfg && exists("generate_synthetic_register")) {
    cat("🧪 Using synthetic data generator (config)\n")
    args <- if (exists("resolve_synthetic_args")) resolve_synthetic_args(cfg) else list()
    if (length(args) == 0) args <- list(n = 5000, months = 12, country = "syria", facilities = 60)
    register <- do.call(generate_synthetic_register, args)

  } else if (exists("load_country_data")) {
    cat("📥 Using multi-country data loader\n")
    register <- load_country_data(country_code, config_env)
    
  } else if (exists("load_dhis2_data") && country_code %in% c("syria", NA, NULL)) {
    # Only use legacy DHIS2 loader for Syria or unspecified countries
    cat("📥 Using DHIS2 data loader (Syria legacy system)\n")
    data_obj <- load_dhis2_data(
      force_refresh = params$force_refresh %||% FALSE,
      config_env = config_env
    )
    register <- data_obj$register %||% data_obj$data
    
  } else if (exists("load_cached_register") && country_code %in% c("syria", NA, NULL)) {
    # Only use cached loader for Syria or unspecified countries
    cat("📥 Using cached data loader (Syria legacy system)\n")
    data_obj <- load_cached_register(config_env = config_env)
    register <- data_obj$register %||% data_obj$data
    
  } else {
    stop("No suitable data loading function available for country: ", country_code %||% "[unspecified]")
  }
  
  # Return in consistent format
  list(register = register, data = register)
  
}, error = function(e) {
  cat("❌ Data loading failed:", e$message, "\n")
  NULL
})

# Extract and validate data
if (!is.null(data_result)) {
  register <- data_result$register %||% data_result$data
  
  if (!is.null(register) && nrow(register) > 0) {
    cat("✅ Data loaded:", nrow(register), "rows,", ncol(register), "columns\n")
    
    # Simple data validation and fixes
    cat("\n=== DATA VALIDATION & CLEANUP ===\n")
    
    # Fix date column if needed
    if (!"datevisit" %in% names(register)) {
      date_candidates <- c("eventdate", "Event date", "occurredat", "visitdate", "date_visit")
      found_date <- intersect(date_candidates, names(register))[1]
      if (!is.na(found_date)) {
        register$datevisit <- register[[found_date]]
        cat("🔧 Created datevisit from", found_date, "\n")
      }
    }
    
    # Ensure dates are properly formatted  
    if ("datevisit" %in% names(register) && !inherits(register$datevisit, "Date")) {
      register$datevisit <- tryCatch({
        as.Date(register$datevisit)
      }, error = function(e) {
        tryCatch(lubridate::ymd(register$datevisit), error = function(e2) {
          tryCatch(lubridate::dmy(register$datevisit), error = function(e3) {
            as.Date(register$datevisit, tryFormats = c("%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y"))
          })
        })
      })
    }
    
    # Create basic derived variables if needed
    if ("datevisit" %in% names(register) && sum(!is.na(register$datevisit)) > 0) {
      if (!"year" %in% names(register)) {
        register$year <- as.integer(lubridate::year(register$datevisit))
      }
      if (!"month" %in% names(register)) {
        register$month <- format(register$datevisit, "%Y-%m")
      }
      
      date_range <- range(register$datevisit, na.rm = TRUE)
      cat("📅 Date range:", date_range[1], "to", date_range[2], "\n")
    }
    
    # Report basic data structure
    essential_cols <- c("datevisit", "morbidity", "canonical_disease_imc")
    found_cols <- intersect(essential_cols, names(register))
    cat("📋 Essential columns:", paste(found_cols, collapse = ", "), "\n")
    
    # Apply full preprocessing pipeline to ensure all taxonomy variables are created
    cat("\n=== TAXONOMY PREPROCESSING ===\n")
    
    if ("morbidity" %in% names(register)) {
      cat("🏷️ Applying full taxonomy preprocessing pipeline...\n")
      
      tryCatch({
        # Use the comprehensive taxonomy processing pipeline
        if (exists("apply_morbidity_categorization")) {
          cat("🔄 Applying comprehensive morbidity categorization...\n")
          register_enhanced <- apply_morbidity_categorization(register)
          
          # Count new taxonomy columns added
          taxonomy_cols <- setdiff(names(register_enhanced), names(register))
          
          if (length(taxonomy_cols) > 0) {
            cat("✅ Added", length(taxonomy_cols), "taxonomy variables:", paste(taxonomy_cols[1:10], collapse = ", "), "...\n")
            
            # Update register with enhanced data
            register <- register_enhanced
            cat("✅ Comprehensive taxonomy preprocessing completed successfully\n")
            
            # Check for base canonical variables
            if ("canonical_disease_imc" %in% names(register)) {
              canonical_count <- sum(!is.na(register$canonical_disease_imc) & register$canonical_disease_imc != "UNMAPPED", na.rm = TRUE)
              canonical_pct <- round((canonical_count / nrow(register)) * 100, 1)
              cat("📊 Canonical diseases mapped:", canonical_count, "records (", canonical_pct, "%)\n")
            }
            
            # Check for ICD-11 variables  
            if ("icd11_code" %in% names(register)) {
              icd11_count <- sum(!is.na(register$icd11_code), na.rm = TRUE)
              icd11_pct <- round((icd11_count / nrow(register)) * 100, 1)
              cat("📊 ICD-11 codes mapped:", icd11_count, "records (", icd11_pct, "%)\n")
            }
            
          } else {
            cat("⚠️ No new taxonomy variables added - data may already be processed\n")
          }
          
        } else {
          cat("❌ apply_morbidity_categorization function not available\n")
          cat("ℹ️ Attempting fallback to legacy taxonomy processing...\n")
          
          # Legacy fallback
          if (exists("apply_simplified_taxonomy")) {
            register <- apply_simplified_taxonomy(register)
            cat("✅ Applied legacy taxonomy processing\n")
          }
        }
        
      }, error = function(e) {
        cat("❌ Taxonomy processing failed:", e$message, "\n")
        cat("   Continuing with original data...\n")
      })
      
    } else {
      cat("⚠️ No morbidity column available for taxonomy processing\n")
    }
    
  } else {
    cat("❌ No valid data received\n")
    register <- NULL
  }
} else {
  cat("❌ Data loading failed completely\n")
  register <- NULL
}

# Create test data if no data available
if (is.null(register) || nrow(register) == 0) {
  cat("\n⚠️ No data available - creating minimal test dataset\n")
  register <- data.frame(
    datevisit = Sys.Date() - 1:10,
    morbidity = rep(c("Diarrhea", "Fever"), 5),
    canonical_disease_imc = rep(c("Diarrhoea (Other)", "Fever (Unspecified)"), 5),
    age = sample(1:70, 10),
    sex = rep(c("M", "F"), 5),
    stringsAsFactors = FALSE
  )
}

cat("\n📊 Final dataset ready:", nrow(register), "rows,", ncol(register), "columns\n")

# Check for expected taxonomy variables
expected_icd11_cols <- c("icd11_code", "icd11_title", "icd11_category")
expected_critical_cols <- c("datevisit", "morbidity", "canonical_disease_imc")

missing_icd11 <- setdiff(expected_icd11_cols, names(register))
missing_critical <- setdiff(expected_critical_cols, names(register))

# Also remove unwanted columns if they exist
if ("standard_disease_imc" %in% names(register)) {
  register$standard_disease_imc <- NULL
  cat("🔧 Removed unwanted 'standard_disease_imc' column\n")
}

```

```{r taxonomy-status, include=FALSE}
    # Report ICD-11 taxonomy status
    if (length(missing_icd11) == 0) {
      cat("✅ ICD-11 taxonomy applied successfully\n")
      unique_icd11_codes <- length(unique(register$icd11_code[!is.na(register$icd11_code)]))
      cat("📊 Found", unique_icd11_codes, "unique ICD-11 disease codes\n")
      
      # Report priority diseases
      if ("is_priority_disease" %in% names(register)) {
        priority_count <- sum(register$is_priority_disease, na.rm = TRUE)
        priority_pct <- round((priority_count / nrow(register)) * 100, 1)
        cat("🎯 Priority diseases:", priority_count, "records (", priority_pct, "%)\n")
      }
      
      # Report epidemiological classifications
      if ("category_canonical_disease_imc" %in% names(register)) {
        epi_summary <- table(register$category_canonical_disease_imc, useNA = "ifany")
        cat("📋 Disease categories:\n")
        for (class in names(epi_summary)) {
          cat("   -", class, ":", epi_summary[class], "cases\n")
        }
      }
    } else {
      cat("⚠️ ICD-11 taxonomy not fully applied. Missing:", paste(missing_icd11, collapse = ", "), "\n")
    }
cat("\n" , rep("=", 50), "\n")
```


```{r icd11-mapping-quality, results='asis', include=FALSE}
# Check for ICD-11 mapping columns (handle both old and new naming conventions)
icd11_cols <- c("icd11_code", "icd11_title", "icd11_category")
confidence_cols <- c("confidence", "icd11_confidence")  # Support both naming conventions
available_icd11_cols <- icd11_cols[icd11_cols %in% names(register)]
available_confidence_cols <- confidence_cols[confidence_cols %in% names(register)]
has_icd11 <- length(available_icd11_cols) >= 2  # At least code and title

if (has_icd11) {
  # Comprehensive mapping quality assessment
  total_diseases <- n_distinct(register$morbidity, na.rm = TRUE)
  total_cases <- nrow(register)

  # Determine which confidence column to use (prefer icd11_confidence over confidence)
  confidence_col <- if(length(available_confidence_cols) > 0) {
    if("icd11_confidence" %in% available_confidence_cols) "icd11_confidence" else available_confidence_cols[1]
  } else NULL

  # Calculate detailed quality metrics
  quality_assessment <- register %>%
    mutate(
      has_code = !is.na(icd11_code) & icd11_code != "" & icd11_code != "Unclassified",
      has_title = !is.na(icd11_title) & icd11_title != "" & icd11_title != "Unclassified",
      has_category = if("icd11_category" %in% names(.)) !is.na(icd11_category) & icd11_category != "" & icd11_category != "Unclassified" else FALSE,
      confidence_level = if(!is.null(confidence_col)) {
        confidence_val <- .data[[confidence_col]]
        case_when(
          is.na(confidence_val) | confidence_val == "" ~ "none",
          confidence_val == "low" ~ "low",
          confidence_val == "medium" ~ "medium",
          confidence_val == "high" ~ "high",
          confidence_val == "WHO_API" ~ "high",  # Treat WHO API as high confidence
          confidence_val == "not_found" ~ "none",
          TRUE ~ "unknown"
        )
      } else {
        # If no confidence column, infer from data quality
        case_when(
          has_code & has_title ~ "medium",
          has_code | has_title ~ "low",
          TRUE ~ "none"
        )
      },
      mapping_status = case_when(
        has_code & has_title & confidence_level == "high" ~ "Complete_High",
        has_code & has_title & confidence_level == "medium" ~ "Complete_Medium",
        has_code & has_title & confidence_level == "low" ~ "Complete_Low", 
        has_code & !has_title ~ "Code_Only",
        !has_code & has_title ~ "Title_Only",
        !has_code & !has_title ~ "Unmapped",
        TRUE ~ "Partial"
      )
    )
  
  # Summary statistics
  quality_stats <- quality_assessment %>%
    summarise(
      complete_high = sum(mapping_status == "Complete_High"),
      complete_medium = sum(mapping_status == "Complete_Medium"), 
      complete_low = sum(mapping_status == "Complete_Low"),
      code_only = sum(mapping_status == "Code_Only"),
      title_only = sum(mapping_status == "Title_Only"),
      unmapped = sum(mapping_status == "Unmapped"),
      partial = sum(mapping_status == "Partial")
    )
  
  high_quality_coverage <- round(quality_stats$complete_high / total_cases * 100, 1)
  overall_coverage <- round((quality_stats$complete_high + quality_stats$complete_medium + quality_stats$complete_low) / total_cases * 100, 1)
  needs_update_pct <- round((quality_stats$unmapped + quality_stats$code_only + quality_stats$title_only + quality_stats$partial) / total_cases * 100, 1)
  
  cat("### Comprehensive ICD-11 Mapping Quality Assessment\n\n")
  
  # Quality summary table
  quality_summary <- data.frame(
    Metric = c("Total Diseases", "Total Records", "High Quality Coverage", "Overall Coverage", "Records Needing Updates"),
    Value = c(
      format(total_diseases, big.mark = ","),
      format(total_cases, big.mark = ","), 
      paste0(high_quality_coverage, "%"),
      paste0(overall_coverage, "%"),
      paste0(needs_update_pct, "%")
    ),
    Status = c(
      "",
      "",
      ifelse(high_quality_coverage >= 80, "✅ EXCELLENT", ifelse(high_quality_coverage >= 60, "⚠️ GOOD", "❌ NEEDS WORK")),
      ifelse(overall_coverage >= 90, "✅ EXCELLENT", ifelse(overall_coverage >= 70, "⚠️ GOOD", "❌ NEEDS WORK")),
      ifelse(needs_update_pct <= 10, "✅ MINIMAL", ifelse(needs_update_pct <= 30, "⚠️ MODERATE", "❌ SIGNIFICANT"))
    )
  )
  
  knitr::kable(quality_summary, 
               caption = "ICD-11 Mapping Quality Overview") %>% 
    print()
  
  cat("\n")
  
  # Detailed breakdown
  cat("#### Mapping Status Breakdown\n\n")
  status_breakdown <- data.frame(
    Status = c("Complete High Confidence", "Complete Medium Confidence", "Complete Low Confidence", 
               "Code Only (Missing Title)", "Title Only (Missing Code)", "Unmapped", "Partial/Other"),
    Records = c(
      format(quality_stats$complete_high, big.mark = ","),
      format(quality_stats$complete_medium, big.mark = ","),
      format(quality_stats$complete_low, big.mark = ","),
      format(quality_stats$code_only, big.mark = ","),
      format(quality_stats$title_only, big.mark = ","),
      format(quality_stats$unmapped, big.mark = ","),
      format(quality_stats$partial, big.mark = ",")
    ),
    Percentage = c(
      paste0(round(quality_stats$complete_high / total_cases * 100, 1), "%"),
      paste0(round(quality_stats$complete_medium / total_cases * 100, 1), "%"), 
      paste0(round(quality_stats$complete_low / total_cases * 100, 1), "%"),
      paste0(round(quality_stats$code_only / total_cases * 100, 1), "%"),
      paste0(round(quality_stats$title_only / total_cases * 100, 1), "%"),
      paste0(round(quality_stats$unmapped / total_cases * 100, 1), "%"),
      paste0(round(quality_stats$partial / total_cases * 100, 1), "%")
    )
  )
  
  knitr::kable(status_breakdown,
               caption = "Detailed Mapping Status Distribution") %>%
    print()
  
  cat("\n")
  
  # Show action needed based on coverage
  if (high_quality_coverage < 80 || overall_coverage < 90) {
    cat("#### 📊 Generate Comprehensive Quality Report for Manual Updates\n\n")
    cat("**Immediate Action Required:** Run this code to generate a detailed Excel report with prioritized diseases for manual ICD-11 mapping:\n\n")
    cat("```r\n")
    cat("# Install required packages (run once)\n")
    cat("install.packages(c('stringdist', 'cluster'))\n\n")
    cat("# Load validation functions\n")
    cat("source('R/validation_rules.R')\n\n")
    cat("# Generate comprehensive ICD-11 quality report\n")
    cat("quality_report <- export_unmapped_diseases(\n")
    cat("  data = register,\n")
    cat("  output_file = \"icd11_quality_report_", format(Sys.Date(), "%Y_%m_%d"), ".xlsx\",\n")
    cat("  include_low_confidence = TRUE\n")
    cat(")\n\n")
    cat("# View summary results\n")
    cat("print(quality_report$summary_stats)\n")
    cat("```\n\n")
    
    cat("**The generated Excel file contains 4 sheets:**\n\n")
    cat("1. **Summary**: Overall quality statistics and coverage metrics\n")
    cat("2. **Diseases_Needing_Updates**: Priority-ranked diseases with empty columns for:\n")
    cat("   - `new_icd11_code`: Fill with ICD-11 code (e.g., CA41.Z)\n")
    cat("   - `new_icd11_title`: Fill with official ICD-11 title\n") 
    cat("   - `new_icd11_category`: Fill with disease category\n")
    cat("   - `new_confidence`: Set confidence level (high/medium/low)\n")
    cat("   - `notes`: Add mapping rationale\n")
    cat("3. **Complete_Analysis**: Full quality assessment of all diseases\n")
    cat("4. **Instructions**: Comprehensive step-by-step update guide\n\n")
    
    cat("#### 🔧 Manual Update Process (Detailed)\n\n")
    cat("**Step 1: Research ICD-11 Codes**\n")
    cat("- Primary source: https://icd.who.int/browse11\n")
    cat("- Search by disease name, symptoms, or body system\n") 
    cat("- Note both code (e.g., 'CA41.Z') and official title\n")
    cat("- Consider disease category for classification\n\n")
    
    cat("**Step 2: Update Taxonomy System**\n")
    cat("Edit: `taxonomy/icd11/disease_mappings.yml`\n\n")
    cat("Add under appropriate confidence section:\n")
    cat("```yaml\n")
    cat("high_confidence:\n")
    cat("  'Disease Name':\n") 
    cat("    icd11_code: 'CA41.Z'\n")
    cat("    icd11_title: 'Acute bronchiolitis, unspecified'\n")
    cat("    icd11_category: 'Respiratory diseases'\n")
    cat("    confidence: 'high'\n")
    cat("    source: 'manual'\n")
    cat("    mapped_date: '", as.character(Sys.Date()), "'\n")
    cat("```\n\n")
    
    cat("**Step 3: Quality Control & Validation**\n")
    cat("```r\n")
    cat("# Clean HTML markup from existing mappings\n")
    cat("source('R/taxonomy/icd11_integration.R')\n")
    cat("cleanup_existing_mappings()\n\n")
    cat("# Reload data to apply new mappings\n")
    cat("# [Reload your data source]\n\n")
    cat("# Re-run quality assessment to verify improvements\n")
    cat("updated_report <- export_unmapped_diseases(data = register)\n")
    cat("```\n\n")
    
  } else {
    cat("#### ✅ Excellent Mapping Quality\n\n")
    cat("**High quality coverage:** ", high_quality_coverage, "%\n")
    cat("**Overall coverage:** ", overall_coverage, "%\n\n") 
    cat("*No immediate action required. System is performing well.*\n\n")
  }
  
  # Show top diseases needing attention
  diseases_needing_work <- quality_assessment %>%
    filter(mapping_status %in% c("Unmapped", "Code_Only", "Title_Only", "Partial")) %>%
    count(morbidity, mapping_status, sort = TRUE, name = "cases") %>%
    head(10) %>%
    mutate(
      percentage = round(cases / total_cases * 100, 1),
      action_needed = case_when(
        mapping_status == "Unmapped" ~ "Add code and title",
        mapping_status == "Code_Only" ~ "Add title", 
        mapping_status == "Title_Only" ~ "Add code",
        TRUE ~ "Complete mapping"
      )
    ) %>%
    select(morbidity, cases, percentage, mapping_status, action_needed)
  
  if (nrow(diseases_needing_work) > 0) {
    cat("#### Top Priority Diseases for Manual Updates\n\n")
    knitr::kable(diseases_needing_work,
                 col.names = c("Disease", "Cases", "% of Total", "Status", "Action Needed"),
                 caption = "Diseases with highest case counts needing ICD-11 mapping improvements") %>%
      print()
  }
  
} else {
  cat("### ICD-11 System Status\n\n")
  cat("**Available columns:** ", paste(available_cols, collapse = ", "), "\n")
  cat("**Status:** ICD-11 mapping system not fully available in current dataset.\n\n")
  cat("*To enable ICD-11 mapping, ensure your data includes: icd11_code, icd11_title, confidence columns.*\n")
}
```


```{r ml-disease-mapping, results='asis', include=FALSE}
# Check if ML mapping is feasible
if (has_icd11) {

  # Check training data availability (reuse confidence logic from above)
  training_data_check <- if(!is.null(confidence_col)) {
    register %>%
      filter(
        !is.na(icd11_code) & icd11_code != "" & icd11_code != "Unclassified",
        !is.na(icd11_title) & icd11_title != "" & icd11_title != "Unclassified",
        .data[[confidence_col]] %in% c("high", "medium", "WHO_API")
      ) %>%
      nrow()
  } else {
    # If no confidence column, count all records with both code and title
    register %>%
      filter(
        !is.na(icd11_code) & icd11_code != "" & icd11_code != "Unclassified",
        !is.na(icd11_title) & icd11_title != "" & icd11_title != "Unclassified"
      ) %>%
      nrow()
  }

  # Check diseases needing mapping improvements (unmapped or incomplete)
  unmapped_check <- register %>%
    mutate(
      # Convert to character first
      morbidity = as.character(morbidity),
      icd11_code = as.character(icd11_code),
      icd11_title = as.character(icd11_title),
      has_code = !is.na(icd11_code) & icd11_code != "" & icd11_code != "Unclassified",
      has_title = !is.na(icd11_title) & icd11_title != "" & icd11_title != "Unclassified",
      has_category = if("icd11_category" %in% names(.)) !is.na(icd11_category) & icd11_category != "" & icd11_category != "Unclassified" else FALSE,
      # Reuse the confidence level logic from above
      confidence_level = if(!is.null(confidence_col)) {
        confidence_val <- .data[[confidence_col]]
        case_when(
          is.na(confidence_val) | confidence_val == "" ~ "none",
          confidence_val == "low" ~ "low",
          confidence_val == "medium" ~ "medium",
          confidence_val == "high" ~ "high",
          confidence_val == "WHO_API" ~ "high",
          confidence_val == "not_found" ~ "none",
          TRUE ~ "unknown"
        )
      } else {
        case_when(
          has_code & has_title ~ "medium",
          has_code | has_title ~ "low",
          TRUE ~ "none"
        )
      },
      needs_improvement = !has_code | !has_title | confidence_level %in% c("none", "low")
    ) %>%
    filter(needs_improvement) %>%
    group_by(morbidity) %>%
    summarise(total_cases = n(), .groups = "drop") %>%
    filter(total_cases >= 10) %>%
    nrow()
  
  cat("### AI-Powered Disease Mapping Analysis\n\n")
  
  if (training_data_check >= 10 && unmapped_check > 0) {
    cat("#### ✅ ML Mapping System Ready\n\n")
    cat("**Training data available:** ", training_data_check, " high-confidence mappings\n")
    cat("**Diseases needing improvement (≥10 cases):** ", unmapped_check, " diseases eligible for ML mapping\n\n")
    
    cat("#### How ML Disease Mapping Works\n\n")
    cat("1. **Training Phase:** Uses existing high and medium confidence mappings as training data\n")
    cat("2. **Similarity Analysis:** Applies multiple text similarity algorithms (Jaccard, Jaro-Winkler, word matching)\n")
    cat("3. **Confidence Scoring:** Assigns confidence levels based on similarity scores and pattern matching\n")
    cat("4. **Manual Review:** Provides Excel export for expert review and approval\n")
    cat("5. **Application:** Applies approved mappings back to the dataset\n\n")
    
    cat("#### Step-by-Step ML Mapping Workflow\n\n")
    cat("**Step 1: Generate ML Suggestions**\n")
    cat("```r\n")
    cat("# Install required packages (run once if not already installed)\n")
    cat("install.packages(c('stringdist', 'cluster'))\n\n")
    cat("# Load validation functions\n")
    cat("source('R/validation_rules.R')\n\n")
    cat("# Apply machine learning to suggest ICD-11 mappings\n") 
    cat("ml_suggestions <- apply_ml_disease_mapping(\n")
    cat("  data = register,\n")
    cat("  min_cases = 10,          # Minimum cases per disease\n")
    cat("  similarity_threshold = 0.6  # Minimum similarity score (0-1)\n")
    cat(")\n\n")
    cat("# View summary of suggestions\n")
    cat("cat('Generated', nrow(ml_suggestions), 'mapping suggestions')\n")
    cat("```\n\n")
    
    cat("**Step 2: Export for Manual Review**\n")
    cat("```r\n")
    cat("# Export suggestions to Excel for expert review\n")
    cat("export_results <- export_ml_suggestions(\n")
    cat("  ml_suggestions = ml_suggestions,\n")
    cat("  output_file = 'ml_disease_mapping_suggestions.xlsx'\n")
    cat(")\n\n")
    cat("# This creates a comprehensive Excel workbook with:\n")
    cat("# - ML_Suggestions sheet (main review interface)\n")
    cat("# - Review_Instructions sheet (detailed guidance)\n")
    cat("# - Summary sheet (statistics and overview)\n")
    cat("```\n\n")
    
    cat("**Step 3: Manual Review Process**\n\n")
    cat("The Excel file provides a structured review interface with:\n\n")
    cat("- **Color coding** by confidence level (green = medium, yellow = low, orange = very low)\n")
    cat("- **Multiple suggestions** for each disease (primary + 2 alternatives)\n") 
    cat("- **Review columns** for APPROVE/REJECT/MODIFY decisions\n")
    cat("- **Similarity scores** to assess mapping quality\n")
    cat("- **Detailed instructions** for clinical appropriateness assessment\n\n")
    
    cat("**Review Status Options:**\n")
    cat("- `APPROVE`: Accept ML suggestion as-is\n")
    cat("- `REJECT`: Reject suggestion entirely\n") 
    cat("- `MODIFY`: Accept but modify the ICD-11 code/title/category\n\n")
    
    cat("**Step 4: Apply Reviewed Mappings**\n")
    cat("```r\n")
    cat("# After completing manual review, apply approved mappings\n")
    cat("results <- apply_reviewed_ml_mappings(\n")
    cat("  reviewed_file = 'ml_disease_mapping_suggestions.xlsx',\n") 
    cat("  data = register\n")
    cat(")\n\n")
    cat("# Access updated dataset\n")
    cat("updated_register <- results$updated_data\n")
    cat("cat('Applied', results$mappings_applied, 'new mappings')\n")
    cat("```\n\n")
    
    cat("**Step 5: Validate Results**\n")
    cat("```r\n")
    cat("# Re-run quality assessment to measure improvement\n")
    cat("export_unmapped_diseases(data = updated_register)\n\n")
    cat("# Compare coverage before/after ML application\n")
    cat("# [Coverage improvement statistics will be displayed]\n")
    cat("```\n\n")
    
    cat("#### One-Click ML Mapping (Quick Start)\n\n")
    cat("For rapid implementation, use the integrated workflow:\n")
    cat("```r\n")
    cat("# Install required packages (run once)\n")
    cat("install.packages(c('stringdist', 'cluster'))\n\n")
    cat("# Complete ML mapping workflow\n")
    cat("source('R/validation_rules.R')\n\n")
    cat("# Generate and export ML suggestions\n")
    cat("ml_suggestions <- apply_ml_disease_mapping(register)\n")
    cat("export_ml_suggestions(ml_suggestions)\n\n")
    cat("# 1. Review the exported Excel file\n")
    cat("# 2. Complete the review columns\n") 
    cat("# 3. Save the file\n")
    cat("# 4. Run: apply_reviewed_ml_mappings('ml_disease_mapping_suggestions.xlsx', register)\n")
    cat("```\n\n")
    
    cat("#### Quality Assurance Guidelines\n\n")
    cat("**Similarity Score Interpretation:**\n")
    cat("- **0.80-1.00:** Very high similarity (usually safe to approve)\n")
    cat("- **0.60-0.79:** Medium similarity (review carefully)\n")
    cat("- **0.40-0.59:** Lower similarity (likely needs modification)\n\n")
    
    cat("**Clinical Review Checklist:**\n")
    cat("✓ Verify clinical appropriateness of suggested mappings\n")
    cat("✓ Check alternative suggestions before final decision\n")
    cat("✓ Consider disease severity and specificity requirements\n") 
    cat("✓ Ensure consistency with existing mapping patterns\n")
    cat("✓ Document rationale for complex decisions\n\n")
    
    cat("**Expected Impact:**\n")
    cat("- ML mapping typically improves coverage by 15-30%\n")
    cat("- Focus on high-case-count diseases for maximum impact\n")
    cat("- Medium confidence ML suggestions often achieve 70-85% accuracy\n")
    cat("- Human review ensures clinical appropriateness and quality\n\n")
    
  } else if (training_data_check < 10) {
    cat("#### ⚠️ Insufficient Training Data\n\n")
    cat("**Training data available:** ", training_data_check, " mappings\n")
    cat("**Required for ML:** At least 10 high-confidence mappings\n\n")
    cat("**Action Required:**\n")
    cat("1. Complete more manual ICD-11 mappings using the quality control workflow above\n")
    cat("2. Ensure mappings have 'high' or 'medium' confidence levels\n")
    cat("3. Return to this ML workflow once sufficient training data is available\n\n")
    
  } else {
    cat("#### ✅ All Diseases Have Adequate Mappings\n\n")
    cat("**Status:** All diseases with significant case counts (≥10) have complete, high-confidence mappings\n")
    cat("**ML mapping not needed at this time**\n\n")
    cat("*Consider lowering the minimum case threshold if mapping of rare diseases is desired.*\n\n")
  }
  
} else {
  cat("### ML Mapping Requirements\n\n")
  cat("**Status:** ICD-11 mapping system not available\n\n")
  cat("*To enable ML-powered disease mapping, ensure your dataset includes:*\n")
  cat("- `icd11_code` column\n")
  cat("- `icd11_title` column\n") 
  cat("- `confidence` column\n\n")
}
```


```{r orgunit-metadata-check, message=FALSE, warning=FALSE, include=FALSE}
required_attrs <- c("region","admin1","admin2","admin3","facility_type")

# Prefer cached results; else run validator
ou_result <- tryCatch({
  if (exists("validation_results") && is.list(validation_results) &&
      !is.null(validation_results$orgunit_metadata)) {
    validation_results$orgunit_metadata
  } else if (exists("validate_orgunit_metadata")) {
    meta_ou <- if (exists("metadata") && is.list(metadata)) metadata$orgunits else NULL
    validate_orgunit_metadata(register, meta_ou, required_cols = required_attrs)
  } else {
    list(valid = NA, issues = tibble::tibble(), warnings = "Org unit metadata validator not available.", summary = list())
  }
}, error = function(e) {
  list(valid = NA, issues = tibble::tibble(), warnings = e$message, summary = list())
})

# Headline summary
n_fac <- if (!is.null(ou_result$summary$n_facilities)) ou_result$summary$n_facilities else NA_integer_
n_iss <- if (!is.null(ou_result$summary$n_with_issues)) ou_result$summary$n_with_issues else nrow(ou_result$issues)
cat(sprintf("**Facilities in data:** %s | **Facilities needing updates:** %s\n\n", n_fac, n_iss))

# Notes / warnings
if (length(ou_result$warnings)) {
  cat("**Note(s):**\n")
  for (w in ou_result$warnings) cat("- ", w, "\n")
  cat("\n")
}

# Utility
is_missing_val <- function(x) { x <- as.character(x); is.na(x) | trimws(x) == "" }

if (is.data.frame(ou_result$issues) && nrow(ou_result$issues) > 0) {
  issues <- ou_result$issues
  attrs_present <- intersect(required_attrs, names(issues))

  # Quick summary: missing by attribute
  if (length(attrs_present)) {
    miss_counts <- sapply(attrs_present, function(col) sum(is_missing_val(issues[[col]])))
    miss_df <- data.frame(Attribute = attrs_present, `# Missing` = as.integer(miss_counts), check.names = FALSE)
    if (requireNamespace("DT", quietly = TRUE)) {
      DT::datatable(miss_df, rownames = FALSE, options = list(dom = "t", ordering = TRUE),
                    caption = "Missing by attribute") 
    } else if (requireNamespace("knitr", quietly = TRUE)) {
      knitr::kable(miss_df, caption = "Missing by attribute")
    } else {
      print(miss_df)
    }
    cat("\n")
  }

  # Build display table: unmatched first, more-missing first
  count_missing_fields <- function(s) ifelse(is.na(s) | s == "", 0L, lengths(strsplit(s, ",\\s*")))
  disp_missing <- function(v) { v <- as.character(v); v[is_missing_val(v)] <- "\u26A0 missing"; v }

  tbl <- issues |>
    dplyr::mutate(
      unmatched  = grepl("metadata_row", missing_fields),
      n_missing  = count_missing_fields(missing_fields)
    ) |>
    dplyr::arrange(dplyr::desc(unmatched), dplyr::desc(n_missing), orgunit) |>
    dplyr::select(
      orgunit, orgunit_uid, orgunit_name,
      dplyr::all_of(attrs_present),
      n_missing, missing_fields
    )

  # Replace empty/NA attribute cells with "⚠ missing" for visual emphasis
  for (col in attrs_present) tbl[[col]] <- disp_missing(tbl[[col]])

  # Render
  if (requireNamespace("DT", quietly = TRUE)) {
    dt <- DT::datatable(
      tbl,
      rownames = FALSE,
      extensions = "Buttons",
      options = list(
        dom = "Bfrtip",
        buttons = list("copy", "csv"),
        pageLength = 15,
        order = list(list(which(names(tbl) == "n_missing") - 1, "desc"))
      ),
      caption = "Facilities missing Org Unit metadata attributes"
    )
    # Highlight missing cells
    for (col in attrs_present) {
      dt <- DT::formatStyle(
        dt, col,
        target = "cell",
        fontWeight = DT::styleEqual("\u26A0 missing", "bold"),
        color = DT::styleEqual("\u26A0 missing", "#B00020"),
        backgroundColor = DT::styleEqual("\u26A0 missing", "#FFF2F2")
      )
    }
    DT::formatStyle(dt, "n_missing", fontWeight = "bold")
  } else if (requireNamespace("knitr", quietly = TRUE)) {
    knitr::kable(tbl, caption = "Facilities missing Org Unit metadata attributes")
  } else {
    print(tbl)
  }

} else if (isTRUE(ou_result$valid)) {
  cat("✅ All facilities referenced in the data appear to have required Org Unit metadata.\n")
} else {
  cat("⚠️ Validation did not complete or found no joinable metadata. See notes above.\n")
}

```

```{r calculate-summary-variables, include = FALSE}
# STEP 1: Load disease categorization functions FIRST
disease_cat_path <- here::here("R", "disease_categories_taxaware.R")
if (file.exists(disease_cat_path)) {
  source(disease_cat_path, local = .GlobalEnv)
  cat("✅ Loaded disease_categories_taxaware.R\n")
} else {
  stop("disease_categories_taxaware.R not found at: ", disease_cat_path)
}

# STEP 2: Load summary functions
summary_func_path <- here::here("R", "summary_functions.R")
if (file.exists(summary_func_path)) {
  source(summary_func_path, local = .GlobalEnv)
  cat("✅ Loaded summary_functions.R\n")
} else {
  stop("summary_functions.R not found. Please save the fixed summary functions.")
}

# Load geographic helpers and visualization functions
geo_helpers_path <- here::here("R", "geographic_helpers.R")
viz_helpers_path <- here::here("R", "visualization_helpers.R")

if (file.exists(geo_helpers_path)) {
  source(geo_helpers_path, local = .GlobalEnv)
  cat("✅ Loaded geographic_helpers.R\n")
} else {
  cat("⚠️ geographic_helpers.R not found\n")
}

if (file.exists(viz_helpers_path)) {
  source(viz_helpers_path, local = .GlobalEnv)
  cat("✅ Loaded visualization_helpers.R\n")
} else {
  cat("⚠️ visualization_helpers.R not found\n")
}

# STEP 3: Verify required functions are available  
required_functions <- c(
  "get_epidemic_groups",
  "get_malnutrition_labels", 
  "get_trauma_morbidities",
  "epidemic_surveillance_table",
  "calculate_all_summary_variables",
  "setup_geospatial_environment",
  "create_geographic_summary_table",
  "create_consultation_choropleth"
)

missing_functions <- c()
for (func in required_functions) {
  if (!exists(func, mode = "function")) {
    missing_functions <- c(missing_functions, func)
  }
}
if (length(missing_functions) > 0) {
  stop("Missing required functions: ", paste(missing_functions, collapse = ", "))
}
cat("✅ All required functions verified\n")

# Ensure validation_results exists (defensive)
if (!exists("validation_results")) {
  validation_results <- list(valid = NA, issues = NULL, warnings = character(0), summary = list())
}



# STEP 4: Calculate ALL summary variables using the fixed functions
summary_vars <- calculate_all_summary_variables(register, validation_results)

# After: summary_vars <- calculate_all_summary_variables(register, validation_results)
summary_vars <- augment_summary_vars(register, summary_vars)

# (Optional) Ensure top_diseases_pct is available as a standalone too:
top_diseases_pct <- summary_vars$top_diseases_pct

# (Optional fallbacks if your pipeline sometimes skips these)
if (!exists("malnutrition_summary") || is.null(malnutrition_summary)) {
  malnutrition_summary <- safe_malnutrition_summary(register, summary_vars)
}
if (!exists("trauma_summary") || is.null(trauma_summary)) {
  trauma_summary <- safe_trauma_summary(register, summary_vars)
}

# STEP 5: Calculate specialized summaries
malnutrition_summary <- if (exists("calculate_malnutrition_summary")) {
  calculate_malnutrition_summary(register, summary_vars)
} else {
  list(total_cases = summary_vars$malnutrition_cases_count)
}

# Uses build_epidemic_surveillance internally; that function now reads epi.date_end
epidemic_summary <- calculate_epidemic_summary(register, summary_vars)

# NOTE: epidemic_surveillance_table() wants the register, not the summary
surveillance_table <- epidemic_surveillance_table(
  register,
  period_days = 30,
  min_cases = 2
)

trauma_summary <- if (exists("calculate_trauma_summary")) {
  calculate_trauma_summary(register, summary_vars)
} else {
  # Safe fallback with defensive programming
  trauma_count <- if (is.null(summary_vars$trauma_cases_count)) 0 else summary_vars$trauma_cases_count
  trauma_count <- if (length(trauma_count) == 0) 0 else trauma_count[1]  # Take first element if vector
  
  list(
    total_trauma_cases = trauma_count,
    trauma_percentage = ifelse(nrow(register) > 0, 
                              round(trauma_count / nrow(register) * 100, 1), 0),
    regions_with_trauma = NA,
    trauma_summary = list()
  )
}

# STEP 6: Extract individual variables for backward compatibility
total_consultations <- summary_vars$total_consultations
total_facilities <- summary_vars$total_facilities  
date_range_text <- summary_vars$date_range_text
monthly_change_pct <- summary_vars$monthly_change_pct
monthly_change_direction <- summary_vars$monthly_change_direction
monthly_change_color <- summary_vars$monthly_change_color
disease_categories_count <- summary_vars$disease_categories_count
epidemic_cases_count <- summary_vars$epidemic_cases_count
trauma_cases_count <- summary_vars$trauma_cases_count
malnutrition_cases_count <- summary_vars$malnutrition_cases_count
# Calculate reliable performance indicators from actual data  
geographic_coverage <- summary_vars$geographic_coverage %||% 0
pediatric_percentage <- summary_vars$pediatric_percentage %||% 0
female_percentage <- summary_vars$female_percentage %||% 0
current_date <- summary_vars$current_date
one_month_ago <- summary_vars$one_month_ago
one_week_ago <- summary_vars$one_week_ago


# Extract epidemic-specific variables
total_epidemic_cases <- epidemic_summary$total_cases
epidemic_surveillance_summary <- epidemic_summary$surveillance_summary %||% tibble::tibble()
high_alert_diseases <- epidemic_summary$high_alert_diseases %||% 0
medium_alert_diseases <- epidemic_summary$medium_alert_diseases %||% 0

# Alert diseases text for compatibility
alert_diseases_text <- if (high_alert_diseases > 0) {
  paste(high_alert_diseases, "high-priority")
} else if (medium_alert_diseases > 0) {
  paste(medium_alert_diseases, "medium-priority") 
} else {
  "No"
}

# Create standard summary objects for sections that expect them
columns <- summary_vars$columns

top_diseases_pct <- if (!is.null(columns$disease_col) && !is.na(columns$disease_col)) {
  register %>%
    dplyr::filter(!is.na(.data[[columns$disease_col]])) %>%
    dplyr::count(.data[[columns$disease_col]], sort = TRUE, name = "n") %>%
    dplyr::mutate(percentage = round(n / sum(n) * 100, 1)) %>%
    dplyr::slice_head(n = 3)
} else {
  tibble::tibble()
}

# Store summary_vars globally for use throughout the document
assign("GLOBAL_SUMMARY_VARS", summary_vars, envir = .GlobalEnv)
assign("GLOBAL_EPIDEMIC_SUMMARY", epidemic_summary, envir = .GlobalEnv)
assign("GLOBAL_MALNUTRITION_SUMMARY", malnutrition_summary, envir = .GlobalEnv)
assign("GLOBAL_TRAUMA_SUMMARY", trauma_summary, envir = .GlobalEnv)

cat("✅ Fixed summary variables calculated successfully\n")
cat("📊 FINAL RESULTS:\n")
cat("   - Total consultations:", scales::comma(total_consultations), "\n")
cat("   - Facilities:", total_facilities, "\n") 
cat("   - Date range:", date_range_text, "\n")
cat("   - Quality score:", summary_vars$quality_score, "/100\n")
cat("   - Disease categories:", disease_categories_count, "\n")
cat("   - Epidemic cases:", epidemic_cases_count, "\n")
cat("   - Malnutrition cases:", malnutrition_cases_count, "\n")
cat("   - Trauma cases:", trauma_summary$total_trauma_cases, "\n")
cat("   - Trauma percentage:", trauma_summary$trauma_percentage, "%\n")
cat("   - Functions available:", summary_vars$functions_available, "\n")
```

```{r initialize-ai-system, include = FALSE}
# --- Source AI modules once (quietly) ---
suppressPackageStartupMessages({
  library(dplyr); library(lubridate); library(rlang)
})
`%||%` <- function(x, y) if (is.null(x) || length(x) == 0) y else x

# Make sure these paths match your repo layout
# Load consolidated AI system
suppressMessages({
  if (file.exists(here::here("R", "ai", "ai_loader.R"))) {
    cat("📦 Loading consolidated AI system...\n")
    source(here::here("R", "ai", "ai_loader.R"))
    cat("✅ Consolidated AI system loaded successfully\n")
  } else {
    cat("⚠️ Consolidated AI system not found, attempting legacy loading...\n")
    # Fallback to legacy loading for backward compatibility
    if (file.exists(here::here("R", "enhanced_ai.R")))     source(here::here("R", "enhanced_ai.R"))
    if (file.exists(here::here("modules", "ai_config.R"))) source(here::here("modules", "ai_config.R"))
    cat("📦 Legacy AI modules loaded\n")
  }
})

# AI functions are now handled by the consolidated AI loader system

# ---- Load configuration and initialize AI system ----
# Load configuration first using the dedicated R markdown function
config_result <- tryCatch({
  safe_load_config_rmd(params$config_env %||% "default")
}, error = function(e) {
  cat("⚠️ Config loading error:", as.character(e$message), "\n")
  list(success = FALSE, config = NULL)
})

# Extract config or create fallback
if (is.logical(config_result) || !config_result$success || is.null(config_result$config)) {
  cat("⚠️ Config loading failed - using minimal config for AI initialization\n")
  cfg <- list(
    ai_features = list(enabled = params$enable_ai %||% TRUE),  # Use params to enable AI
    dhis2 = list(base_url = "", username = "", password = ""),
    parameters = list()
  )
} else {
  cfg <- config_result$config
  # Ensure AI features structure exists and is enabled based on params
  if (is.null(cfg$ai_features)) {
    cfg$ai_features <- list()
  }
  if (is.null(cfg$ai_features$enabled)) {
    cfg$ai_features$enabled <- params$enable_ai %||% TRUE
  }
}

# Initialize AI system with register context (data context-aware initialization)
cat("🔧 AI Configuration Debug:\n")
cat("   - params$enable_ai:", as.character(params$enable_ai %||% "NULL"), "\n")
cat("   - cfg$ai_features$enabled:", as.character(cfg$ai_features$enabled %||% "NULL"), "\n")
cat("   - initialize_ai_for_report exists:", exists("initialize_ai_for_report"), "\n")

ai_system <- tryCatch({
  if (exists("initialize_ai_for_report")) {
    initialize_ai_for_report(cfg, params, register)
  } else {
    # Fallback if consolidated system not available
    cat("⚠️ Consolidated AI system not found, using fallback initialization\n")
    list(available = FALSE, error_message = "Consolidated AI system not loaded", fallback_mode = TRUE)
  }
}, error = function(e) {
  cat("❌ AI initialization error:", as.character(e$message), "\n")
  list(available = FALSE, error_message = as.character(e$message), fallback_mode = TRUE)
})
cat("🤖 AI System Status:", if (isTRUE(ai_system$available)) "✅ Available" else "❌ Not Available", "\n")
if (!isTRUE(ai_system$available)) cat("   Reason:", as.character(ai_system$error_message %||% "Unknown"), "\n")
if (isTRUE(ai_system$available) && !is.null(ai_system$register_context)) {
  cat("📊 Data Context: ", as.character(ai_system$register_context$total_cases %||% 0), " records, ", 
      length(ai_system$register_context$top_diseases %||% list()), " diseases, ",
      length(ai_system$register_context$regions %||% character()), " areas\n")
  
  # Report ICD-11 context for AI
  if ("icd11_code" %in% names(register)) {
    # Check if category column exists, use it if available, otherwise just count by icd11 fields
    if ("category_canonical_disease_imc" %in% names(register)) {
      icd11_summary <- register %>%
        filter(!is.na(icd11_code) & icd11_code != "UNMAPPED") %>%
        count(icd11_code, icd11_title, category_canonical_disease_imc, sort = TRUE) %>%
        head(5)
    } else {
      icd11_summary <- register %>%
        filter(!is.na(icd11_code) & icd11_code != "UNMAPPED") %>%
        count(icd11_code, icd11_title, sort = TRUE) %>%
        head(5)
      # Add placeholder category column
      icd11_summary$category_canonical_disease_imc <- "Unknown"
    }
    
    if (nrow(icd11_summary) > 0) {
      cat("🏷️ ICD-11 Context for AI:\n")
      for (i in 1:nrow(icd11_summary)) {
        cat("   -", as.character(icd11_summary$icd11_title[i]), "(", as.character(icd11_summary$icd11_code[i]), "):", 
            as.character(icd11_summary$n[i]), "cases -", as.character(icd11_summary$category_canonical_disease_imc[i]), "\n")
      }
      
      # Add ICD-11 context to AI system
      ai_system$icd11_context <- list(
        total_icd11_mapped = sum(!is.na(register$icd11_code) & register$icd11_code != "UNMAPPED"),
        top_icd11_diseases = icd11_summary,
        priority_disease_count = if ("is_priority_disease" %in% names(register)) sum(register$is_priority_disease, na.rm = TRUE) else 0,
        classifications = if ("category_canonical_disease_imc" %in% names(register)) table(register$category_canonical_disease_imc, useNA = "no") else NULL
      )
    }
  }
  
  # Debug: Show available columns and detected regions
  cat("🔍 Column Debug - Available columns: ", paste(names(register)[1:min(10, length(names(register)))], collapse = ", "), "...\n")
  if (length(ai_system$register_context$regions) == 0) {
    geo_cols <- intersect(c("admin1", "region", "governorate"), names(register))
    cat("🔍 Geographic columns found: ", paste(geo_cols, collapse = ", "), "\n")
    if (length(geo_cols) > 0 && geo_cols[1] %in% names(register)) {
      unique_vals <- unique(register[[geo_cols[1]]])
      cat("🔍 Unique values in", geo_cols[1], ":", length(unique_vals), "values:", paste(head(as.character(unique_vals), 3), collapse = ", "), "...\n")
    }
  }
}

# Compute ai_summaries once here so downstream chunks can safely use it
cat("🔧 AI Summaries Debug:\n")
cat("   - ai_system$available:", isTRUE(ai_system$available), "\n")
cat("   - generate_all_ai_summaries exists:", exists("generate_all_ai_summaries"), "\n")
cat("   - generate_fallback_ai_summaries exists:", exists("generate_fallback_ai_summaries"), "\n")

ai_summaries <- tryCatch({
  if (isTRUE(ai_system$available) && exists("generate_all_ai_summaries")) {
    cat("✅ Generating AI summaries with full system\n")
    generate_all_ai_summaries(register, ai_system)
  } else if (exists("generate_fallback_ai_summaries")) {
    cat("ℹ️ Using fallback AI summaries\n")
    generate_fallback_ai_summaries(register, ai_system)
  } else {
    # Ultimate fallback
    cat("⚠️ No AI summary functions available, using basic fallback\n")
    list(
      monthly_summary = "Standard epidemiological analysis applied to surveillance data. AI enhancement not available.",
      geographic_insights = "Geographic patterns analyzed using standard methods.",
      demographic_insights = "Demographic analysis using standard statistical approaches.",
      disease_narratives = list(),
      facility_performance = "Facility performance assessed using standard metrics.",
      risk_assessment = "Risk assessment using standard surveillance thresholds.",
      analysis_quality = 60
    )
  }
}, error = function(e) { 
  cat("⚠️ AI summaries failed:", as.character(e$message), "\n")
  # Final fallback with basic content
  list(
    monthly_summary = "Analysis completed using standard statistical methods. Enhanced AI analysis temporarily unavailable.",
    geographic_insights = "Geographic distribution analyzed using conventional epidemiological approaches.",
    demographic_insights = "Demographic patterns assessed through standard statistical analysis.",
    disease_narratives = list(),
    facility_performance = "Health facility utilization assessed using standard performance indicators.",
    risk_assessment = "Risk levels evaluated using established surveillance thresholds and clinical guidelines.",
    analysis_quality = 50
  )
})
```

# Executive Summary

::: executive-summary
**IMC Health Surveillance Report**

This report presents a comprehensive analysis of health service delivery across IMC-supported facilities, providing critical insights for program management and donor reporting. The analysis covers **`r scales::comma(total_consultations)` consultations** delivered across **`r total_facilities`** health facilities during **`r date_range_text`**.

### Performance Indicators

-   **Geographic Coverage**: `r geographic_coverage` governorates covered
-   **Pediatric Care**: `r pediatric_percentage`% of consultations for children
-   **Female Patient Access**: `r female_percentage`% of consultations for women and girls
-   **Monthly Trend**: `r monthly_change_direction` by `r abs(monthly_change_pct)`% compared to previous month
-   **Data Quality Score**: `r summary_vars$quality_score`/100 (based on completeness and accuracy metrics)

### Alert Status Summary

`r if(high_alert_diseases > 0) { paste("🔴", high_alert_diseases, "high-priority epidemic diseases requiring immediate attention") } else if(medium_alert_diseases > 0) { paste("🟡", medium_alert_diseases, "medium-priority diseases under enhanced surveillance") } else { "🟢 No epidemic alerts currently active - routine surveillance continues" }`
:::

```{r executive-summary-calculations, include=FALSE}
# Use already calculated summary variables instead of recalculating
# Most variables are already available from the centralized calculation

# Only calculate what's not already available
seasonal_pattern <- if (!is.na(summary_vars$columns$date_col)) {
  register %>%
    dplyr::mutate(month_name = month.name[lubridate::month(.data[[summary_vars$columns$date_col]])]) %>%
    dplyr::count(month_name, sort = TRUE) %>%
    dplyr::slice_head(n = 1)
} else {
  tibble::tibble()
}

high_risk_age <- if (!is.na(summary_vars$columns$age_col)) {
  register %>%
    dplyr::filter(!is.na(.data[[summary_vars$columns$age_col]])) %>%
    dplyr::count(.data[[summary_vars$columns$age_col]], sort = TRUE) %>%
    dplyr::slice_head(n = 1)
} else {
  tibble::tibble()
}

# Calculate malnutrition trend if not already done
malnutrition_trend <- 0
if (malnutrition_summary$total_cases > 0 && !is.na(summary_vars$columns$date_col)) {
  current_month_malnut <- register %>%
    dplyr::filter(
      if (!is.na(summary_vars$columns$malnutrition_col)) {
        .data[[summary_vars$columns$malnutrition_col]] == 1
      } else {
        .data[[summary_vars$columns$disease_col]] %in% get_malnutrition_labels()
      },
      .data[[summary_vars$columns$date_col]] >= one_month_ago
    ) %>%
    nrow()
  
  prev_month_malnut <- register %>%
    dplyr::filter(
      if (!is.na(summary_vars$columns$malnutrition_col)) {
        .data[[summary_vars$columns$malnutrition_col]] == 1
      } else {
        .data[[summary_vars$columns$disease_col]] %in% get_malnutrition_labels()
      },
      .data[[summary_vars$columns$date_col]] >= (one_month_ago - 30) & 
      .data[[summary_vars$columns$date_col]] < one_month_ago
    ) %>%
    nrow()
  
  if (prev_month_malnut > 0) {
    malnutrition_trend <- round(((current_month_malnut - prev_month_malnut) / prev_month_malnut) * 100, 1)
  }
}
```

```{r executive-summary-ai, results='asis', echo=FALSE}
# Debug: Check AI summaries content (only in dev mode)
if (isTRUE(params$debug) || isTRUE(getOption("epidashboard.debug", FALSE))) {
  cat("🔍 Executive Summary Debug:\n")
  cat("   - params$enable_ai:", as.character(params$enable_ai %||% "NULL"), "\n")
  cat("   - ai_system$available:", isTRUE(ai_system$available), "\n")
  cat("   - monthly_summary exists:", "monthly_summary" %in% names(ai_summaries), "\n")
  if ("monthly_summary" %in% names(ai_summaries)) {
    summary_preview <- substr(ai_summaries$monthly_summary, 1, 100)
    cat("   - monthly_summary preview:", summary_preview, "...\n")
    has_error_text <- grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$monthly_summary %||% "")
    cat("   - contains error text:", has_error_text, "\n")
  }
}

# Display AI-generated executive summary only if AI is enabled
if (isTRUE(params$enable_ai) && isTRUE(ai_system$available) && "monthly_summary" %in% names(ai_summaries) && 
    !grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$monthly_summary %||% "")) {
  cat("## Enhanced Analysis Insights\n\n")
  cat("::: {.ai-enhanced}\n")
  cat("**AI-Powered Epidemiological Analysis")
  
  # Show context if available
  if (!is.null(ai_system$user_customization)) {
    custom <- ai_system$user_customization
    deployment_type <- ai_system$deployment_type %||% "general"
    context_display <- switch(deployment_type,
      "refugee_camp" = "Refugee Camp Context",
      "urban_clinic" = "Urban Clinic Context", 
      "rural_health" = "Rural Health Context",
      "emergency_response" = "Emergency Response Context",
      "General Context"
    )
    cat(" - ", context_display, "**\n\n")
    
    # Brief context info
    if (!is.null(custom$context$setting_description)) {
      cat("*Analysis customized for: ", substr(custom$context$setting_description, 1, 80), "*\n\n")
    }
  } else {
    cat("**\n\n")
  }
  
  cat(format_ai_summary(ai_summaries$monthly_summary, "monthly", FALSE))
  cat("\n\n*Generated using context-aware epidemiological AI models with local data processing for privacy compliance.*\n")
  cat(":::")
  cat("\n\n---\n\n")
} else if (!params$enable_ai) {
  # Only show this message when AI is explicitly disabled, not when it's just unavailable
  cat("\n\n---\n\n")
}
```

# Health Service Utilization Patterns

## Temporal Distribution of Health Services

**Service Delivery Trends: `r scales::comma(total_consultations)` consultations analyzed**

Key patterns from `r date_range_text` data: Service use: peaked in `r val(format(summary_vars$peak_month, "%B %Y"), "—")` at `r fmt_comma(summary_vars$peak_consultations)` visits; month-on-month `r summary_vars$monthly_change_direction %||% "—"` by `r abs(summary_vars$monthly_change_pct %||% NA)`%. Implication: adjust staffing/supplies for high-volume periods.

```{r consultations-over-time, fig.cap="Distribution of consultations over time showing seasonal patterns and trends"}
if (exists("plot_consultations_over_time")) {
  tryCatch({
    # Check for required date column
    date_col <- case_when(
      "datevisit" %in% names(register) ~ "datevisit",
      "eventdate" %in% names(register) ~ "eventdate",
      "date_visit" %in% names(register) ~ "date_visit",
      TRUE ~ NA_character_
    )

    if (!is.na(date_col) && nrow(register) > 0) {
      plot_consultations_over_time(register, "Consultations Over Time")
    } else {
      cat("⚠️ Consultations over time chart: No valid date column found in data\n")
      cat("📊 Available columns:", paste(names(register), collapse = ", "), "\n")
    }
  }, error = function(e) {
    cat("❌ Error creating consultations over time chart:", e$message, "\n")
    # Fall back to manual chart
  })
} else {
  # fallback plot with robust date handling

  # choose the best available date column
  date_col <- dplyr::case_when(
    "datevisit"    %in% names(register) ~ "datevisit",
    TRUE ~ NA_character_
  )

  if (!is.na(date_col)) {
    df_plot <- register |>
      dplyr::mutate(.date = to_date_safe(.data[[date_col]])) |>
      dplyr::filter(!is.na(.date)) |>
      dplyr::count(.date, name = "n") |>
      dplyr::arrange(.date)

    if (nrow(df_plot)) {
      ggplot2::ggplot(df_plot, ggplot2::aes(x = .date, y = n)) +
        ggplot2::geom_line(size = 0.9) +
        ggplot2::geom_smooth(method = "loess", se = TRUE, alpha = 0.25) +
        ggplot2::labs(
          title = "Consultations Over Time",
          x = "Date",
          y = "Number of Consultations"
        ) +
        ggplot2::theme_minimal() +
        ggplot2::scale_y_continuous(labels = scales::comma) +
        ggplot2::scale_x_date(date_labels = "%Y-%m")
    } else {
      cat("No valid dates available for temporal visualization\n")
    }
  } else {
    cat("Date data not available for temporal visualization\n")
  }
}
```

## Geographic Distribution of Health Services

Health services span `r fmt_comma(length(unique(register$admin1[!is.na(register$admin1)])) %||% 0)` governorates with utilization concentrated in `r names(sort(table(register$admin1), decreasing = TRUE))[1] %||% "key areas"` representing `r fmt_pct1((max(table(register$admin1)) / nrow(register)) * 100 %||% 0)`% of total consultations.

```{r geographic-distribution, fig.cap="Number of consultations by administrative region"}
if (exists("plot_geographic_distribution")) {
  tryCatch({
    # Check for required geographic column
    geo_col <- case_when(
      "admin1" %in% names(register) ~ "admin1",
      "governorate" %in% names(register) ~ "governorate",
      "region" %in% names(register) ~ "region",
      TRUE ~ NA_character_
    )

    if (!is.na(geo_col) && nrow(register) > 0) {
      plot_geographic_distribution(register, geo_col, "count")
    } else {
      cat("⚠️ Geographic distribution chart: No valid geographic column found in data\n")
      cat("📊 Available columns:", paste(names(register), collapse = ", "), "\n")
    }
  }, error = function(e) {
    cat("❌ Error creating geographic distribution chart:", e$message, "\n")
    # Fall back to manual chart
  })
} else {
  # Fallback geographic visualization
  geo_col <- case_when(
    "admin1" %in% names(register) ~ "admin1",
    "governorate" %in% names(register) ~ "governorate",
    TRUE ~ NA_character_
  )
  
  if (!is.na(geo_col)) {
    register %>%
      count(.data[[geo_col]], sort = TRUE) %>%
      slice_head(n = 15) %>%
      ggplot(aes(x = reorder(.data[[geo_col]], n), y = n)) +
      geom_col(fill = "#1f77b4", alpha = 0.8) +
      coord_flip() +
      labs(
        title = "Geographic Distribution of Consultations",
        x = "Administrative Region",
        y = "Number of Consultations"
      ) +
      theme_minimal() +
      scale_y_continuous(labels = comma_format())
  } else {
    cat("Geographic data not available for visualization")
  }
}


```

**Key insights:** - **Coverage reach**: `r fmt_comma(length(unique(register$orgunit[!is.na(register$orgunit)])) %||% 0)` facilities across `r length(unique(register$admin1[!is.na(register$admin1)])) %||% 0` governorates - **Volume concentration**: Top region (`r names(sort(table(register$admin1), decreasing = TRUE))[1] %||% "—"`) accounts for `r fmt_comma(max(table(register$admin1)) %||% 0)` consultations\
- **Access equity**: Review bottom-quartile regions for service expansion opportunities

# Patient Demographics and Vulnerable Populations

## Patient Demographics by Quarter {.tabset}

Patient demographics reveal `r fmt_pct1((sum(register$age_group %in% c("0-5 y", "6-17 y"), na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% pediatric consultations and `r fmt_pct1((sum(register$sex == "Female", na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% female patients, indicating high vulnerable population engagement across `r paste(format(min(register$datevisit, na.rm = TRUE), "%b %Y"), "to", format(max(register$datevisit, na.rm = TRUE), "%b %Y")) %||% "reporting period"`.

```{r patient-demographics}
# Create summary table by quarter - with error checking
demo_cols <- intersect(
  c("quarter", "sex", "age_group", "resident", "disability", "admin1", "category_canonical_disease_imc"), 
  colnames(register)
)

if (length(demo_cols) >= 2) {
  
  if ("quarter" %in% demo_cols && "sex" %in% demo_cols) {
    
    available_cols <- intersect(
      c("admin1", "sex", "age_group", "resident", "disability", "category_canonical_disease_imc"), 
      colnames(register)
    )
    
    if (length(available_cols) > 0) {
      # Create dynamic label list for only existing columns in quarterly table
      quarterly_label_list <- list()
      if ("admin1" %in% available_cols) quarterly_label_list$admin1 <- "Administrative Region"
      if ("sex" %in% available_cols) quarterly_label_list$sex <- "Sex"
      if ("age_group" %in% available_cols) quarterly_label_list$age_group <- "Age Group"
      if ("resident" %in% available_cols) quarterly_label_list$resident <- "Resident Status"
      if ("disability" %in% available_cols) quarterly_label_list$disability <- "Disability Status"
      if ("category_canonical_disease_imc" %in% available_cols) quarterly_label_list$category_canonical_disease_imc <- "Disease Category"

      tbl_quarter <- register %>%
        filter(!is.na(quarter)) %>%
        select(quarter, all_of(available_cols)) %>%
        tbl_summary(
          by = quarter,
          include = all_of(available_cols),
          missing = "ifany",
          percent = "column",
          statistic = list(all_categorical() ~ "{n} ({p}%)"),
          label = quarterly_label_list
        ) %>%
        add_n() %>%
        add_overall() %>%
        bold_labels() %>%
        modify_header(label ~ "**Variable**") %>%
        modify_caption("**Health consultations by quarter**")

      tbl_quarter
    }
    
  } else {
    # Fallback: Simple summary without quarters
    basic_cols <- intersect(c("sex", "age_group", "resident", "disability", "category_canonical_disease_imc"), colnames(register))
    
    if (length(basic_cols) > 0) {
      # Create dynamic label list for only existing columns
      label_list <- list()
      if ("admin1" %in% basic_cols) label_list$admin1 <- "Administrative Region"
      if ("sex" %in% basic_cols) label_list$sex <- "Sex"
      if ("age_group" %in% basic_cols) label_list$age_group <- "Age Group"
      if ("resident" %in% basic_cols) label_list$resident <- "Resident Status"
      if ("disability" %in% basic_cols) label_list$disability <- "Disability Status"
      if ("category_canonical_disease_imc" %in% basic_cols) label_list$category_canonical_disease_imc <- "Disease Category"

      tbl_basic <- register %>%
        select(all_of(basic_cols)) %>%
        tbl_summary(
          missing = "ifany",
          percent = "column",
          statistic = list(all_categorical() ~ "{n} ({p}%)"),
          label = label_list
        ) %>%
        add_n() %>%
        bold_labels() %>%
        modify_header(label ~ "**Variable**") %>%
        modify_caption("**Health consultations summary**")
      
      tbl_basic
    }
  }
} else {
  cat("Insufficient demographic data available for summary table")
}
```

## Age-Sex Distribution Analysis

**Population Pyramid: Understanding Service Utilization by Demographics**

Utilization by age/sex: Highest volumes in `r summary_vars$age_peak_group %||% "—"`; female share: `r fmt_pct1(female_percentage %||% NA)`%. Implication: tailor health education and appointment flow to dominant groups.

```{r age-sex-pyramid, fig.cap="Age-sex pyramid showing distribution of consultations by demographic groups"}

if (exists("plot_age_sex_pyramid")) {
  tryCatch({
    # Check for required age and sex columns (same logic as visualization function)
    age_col <- case_when(
      "age_group" %in% names(register) ~ "age_group",
      "age_group_new" %in% names(register) ~ "age_group_new",
      "age_group2" %in% names(register) ~ "age_group2",
      "age_group3" %in% names(register) ~ "age_group3",
      "age_group4" %in% names(register) ~ "age_group4",
      "age_category" %in% names(register) ~ "age_category",
      TRUE ~ NA_character_
    )

    sex_col <- case_when(
      "sex" %in% names(register) ~ "sex",
      "gender" %in% names(register) ~ "gender",
      TRUE ~ NA_character_
    )

    if (!is.na(age_col) && !is.na(sex_col) && nrow(register) > 0) {
      plot_age_sex_pyramid(register)
    } else {
      cat("⚠️ Age-sex pyramid chart: Required age and/or sex columns not found in data\n")
      cat("📊 Available columns:", paste(names(register), collapse = ", "), "\n")
      cat("🔍 Missing: age column (", is.na(age_col), "), sex column (", is.na(sex_col), ")\n")
    }
  }, error = function(e) {
    cat("❌ Error creating age-sex pyramid chart:", e$message, "\n")
    # Fall back to manual chart
  })
} else {
  # Fallback age-sex visualization
  if (!is.na(age_col) && all(c(age_col, "sex") %in% colnames(register))) {
    
    age_sex_data <- register %>%
      dplyr::filter(!is.na(.data[[age_col]]), !is.na(sex)) %>%
      dplyr::count(.data[[age_col]], sex, name = "n") %>%
      dplyr::mutate(
        n = ifelse(sex == "Male", -n, n),
        !!age_col := factor(.data[[age_col]], levels = c("< 5 yrs", "5 - 14 yrs", "15 - 18 yrs", "19 - 49 yrs", ">= 50 yrs"))
      )

    ggplot(age_sex_data, aes(x = .data[[age_col]], y = n, fill = sex)) +
      geom_col() +
      coord_flip() +
      scale_fill_manual(values = c("Female" = "#ff7f0e", "Male" = "#1f77b4")) +
      scale_y_continuous(
        labels = function(x) comma(abs(x)),
        breaks = pretty_breaks(n = 6)
      ) +
      labs(
        title = "Age-Sex Distribution of Consultations",
        x = "Age Group",
        y = "Number of Consultations",
        fill = "Sex"
      ) +
      theme_minimal() +
      theme(legend.position = "bottom")
      
  } else {
    cat("Age and sex data not available for pyramid visualization")
  }
}
```

**Key insights:** - **Vulnerable groups**: `r fmt_pct1((sum(register$age_group %in% c("0-5 y", "6-17 y"), na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% children and `r fmt_pct1((sum(register$sex == "Female", na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% women/girls served - **Seasonal patterns**: `r names(sort(table(register$quarter), decreasing = TRUE))[1] %||% "Q4"` shows highest volume with `r fmt_comma(max(table(register$quarter)) %||% 0)` consultations - **Age distribution**: Under-5 represent `r fmt_pct1((sum(register$age_group %in% c("0-5 y"), na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% requiring specialized pediatric protocols

# Disease Patterns and Health Burden Analysis


## Overall Disease Distribution (Category)

Disease burden (by category) concentrates in `r (top_diseases_pct$category_canonical_disease_imc[1] %||% "respiratory conditions")` representing `r fmt_pct1(top_diseases_pct$percentage[1] %||% 0)`% of consultations, followed by `r (top_diseases_pct$category_canonical_disease_imc[2] %||% "digestive disorders")` at `r fmt_pct1(top_diseases_pct$percentage[2] %||% 0)`%.

```{r disease-distribution, fig.cap="Top 10 disease categories by consultation volume"}
if (exists("plot_disease_distribution")) {
  tryCatch({
    # Check for required disease column
    disease_col <- case_when(
      "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
      "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
      "morbidity" %in% names(register) ~ "morbidity",
      "icd11_title" %in% names(register) ~ "icd11_title",
      TRUE ~ NA_character_
    )

    if (!is.na(disease_col) && nrow(register) > 0) {
      plot_disease_distribution(register, disease_col, 10)
    } else {
      cat("⚠️ Disease distribution chart: No valid disease column found in data\n")
      cat("📊 Available columns:", paste(names(register), collapse = ", "), "\n")
    }
  }, error = function(e) {
    cat("❌ Error creating disease distribution chart:", e$message, "\n")
    # Fall back to manual chart
  })
} else {
  # Fallback disease distribution
  disease_col <- case_when(
    "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
    "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
    "morbidity" %in% names(register) ~ "morbidity",
    TRUE ~ NA_character_
  )
  
  if (!is.na(disease_col)) {
    register %>%
      count(.data[[disease_col]], sort = TRUE) %>%
      slice_head(n = 10) %>%
      mutate(!!disease_col := str_wrap(.data[[disease_col]], 30)) %>%
      ggplot(aes(x = reorder(.data[[disease_col]], n), y = n)) +
      geom_col(fill = "#1f77b4", alpha = 0.8) +
      coord_flip() +
      labs(
        title = "Top 10 Disease Categories",
        x = "Disease Category",
        y = "Number of Cases"
      ) +
      theme_minimal() +
      scale_y_continuous(labels = comma_format())
  } else {
    cat("Disease category data not available")
  }
}
```

**Key insights:** - **Top conditions**: `r (top_diseases_pct$canonical_disease_imc[1] %||% "—")` leads with `r fmt_comma(top_diseases_pct$n[1] %||% 0)` cases (`r fmt_pct1(top_diseases_pct$percentage[1] %||% 0)`%) - **Resource planning**: Top 3 diseases account for `r fmt_pct1(sum(top_diseases_pct$percentage[1:3], na.rm = TRUE))`% of total caseload - **Supply alignment**: Prioritize medications and supplies for leading 5 conditions driving `r fmt_pct1(sum(top_diseases_pct$percentage[1:5], na.rm = TRUE))`% of demand

## Disease Trends Over Time (Top 6)

Disease surveillance reveals `r summary_vars$disease_trend_overall %||% "stable"` patterns with alert threshold at `r summary_vars$alert_threshold_recent_cases %||% 10` cases per 30-day window, requiring monitoring for `r summary_vars$alert_ratio_threshold %||% 2.0`× baseline increases.

```{r disease-trends, fig.cap="Temporal trends in top 6 disease categories", fig.height=8}
if (exists("plot_time_series_by_category")) {
  plot_time_series_by_category(register, "datevisit", "canonical_disease_imc", 6)
} else {
  # --- Fallback time series (robust) ---
  # pick columns
  disease_col <- dplyr::case_when(
    "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
    "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
    "morbidity" %in% names(register) ~ "morbidity",
    TRUE ~ NA_character_
  )
  date_col <- dplyr::case_when(
    "datevisit" %in% names(register) ~ "month2",
    TRUE ~ NA_character_
  )

  # small helper if to_date_safe isn't in scope here
  if (!exists("to_date_safe")) {
    to_date_safe <- function(x) {
      if (inherits(x, "Date"))   return(x)
      if (inherits(x, "POSIXt")) return(as.Date(x))
      x <- as.character(x)
      d <- suppressWarnings(as.Date(x, "%Y-%m-%d"))
      if (all(is.na(d))) d <- suppressWarnings(as.Date(x, "%d/%m/%Y"))
      if (all(is.na(d))) d <- suppressWarnings(lubridate::ymd(x))
      if (all(is.na(d))) d <- suppressWarnings(lubridate::dmy(x))
      d
    }
  }

  if (!is.na(disease_col) && !is.na(date_col) &&
      disease_col %in% names(register) && date_col %in% names(register)) {

    df <- register |>
      dplyr::mutate(
        .dt    = to_date_safe(.data[[date_col]]),
        month2 = lubridate::floor_date(.dt, "month")
      ) |>
      dplyr::filter(!is.na(month2), !is.na(.data[[disease_col]]))

    if (nrow(df) > 0) {
      # top 6 diseases by count
      top_diseases <- df |>
        dplyr::count(.data[[disease_col]], sort = TRUE, name = "n") |>
        dplyr::slice_head(n = 6) |>
        dplyr::pull(.data[[disease_col]])

      if (length(top_diseases)) {
        df_top <- df |>
          dplyr::filter(.data[[disease_col]] %in% top_diseases) |>
          dplyr::count(month2, .data[[disease_col]], name = "n")

        p <- ggplot2::ggplot(
          df_top,
          ggplot2::aes(x = month2, y = n, color = .data[[disease_col]])
        ) +
          ggplot2::geom_line(size = 1.2) +
          ggplot2::geom_point(size = 2) +
          ggplot2::facet_wrap(
            ggplot2::vars(.data[[disease_col]]),
            scales = "free_y", ncol = 2
          ) +
          ggplot2::labs(
            title = "Disease Trends Over Time",
            x = "Month", y = "Number of Cases"
          ) +
          ggplot2::theme_minimal() +
          ggplot2::theme(
            legend.position = "none",
            axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)
          ) +
          ggplot2::scale_y_continuous(labels = scales::comma_format())

        print(p)
      } else {
        cat("No diseases found to plot after filtering.\n")
      }
    } else {
      cat("No rows with valid dates/disease to plot.\n")
    }
  } else {
    cat("Disease or date data not available for time series.\n")
  }
}
```

**Key insights:** - **Trend status**: Overall disease patterns show `r summary_vars$disease_trend_overall %||% "stable"` activity across major categories - **Alert thresholds**: Monitor conditions exceeding `r summary_vars$alert_threshold_recent_cases %||% 10` cases monthly or `r summary_vars$alert_ratio_threshold %||% 2.0`× baseline - **Seasonal patterns**: `r summary_vars$peak_disease_month %||% "Winter months"` typically show elevated respiratory and communicable disease activity

## Geographic Distribution of Disease Burden

Regional disease clustering shows `r summary_vars$top_disease_region %||% "key areas"` concentrating `r fmt_pct1(summary_vars$top_disease_region_share %||% 0)`% of `r summary_vars$top_disease_name %||% "priority conditions"` cases, indicating targeted intervention opportunities.

```{r disease-treemap, fig.cap="Disease category distribution by governorate (treemap visualization)", fig.height=10, fig.width=14}
# Load visualization helpers if not already loaded
if (!exists("create_geographic_disease_treemap")) {
  source(here::here("R", "visualization_helpers.R"))
}

# Create enhanced geographic disease treemap
treemap_plot <- create_geographic_disease_treemap(
  data = register,
  title = "Disease Category Distribution by Governorate",
  color_scheme = "accessible",
  min_cases = 5,
  max_diseases = 12
)

if (!is.null(treemap_plot)) {
  print(treemap_plot)
} else {
  cat("Disease or region columns not available for treemap visualization\n")
}
```

**Key insights:** - **Disease hotspots**: `r summary_vars$top_disease_region %||% "—"` accounts for `r fmt_pct1(summary_vars$top_disease_region_share %||% 0)`% of `r summary_vars$top_disease_name %||% "cases"` - **Geographic spread**: `r summary_vars$diseases_geographic_reach %||% 0` regions affected by top 3 conditions requiring coordinated response - **Targeted interventions**: Focus mobile clinics and outreach programs on high-burden districts showing `r summary_vars$disease_concentration_ratio %||% 2.0`× average rates

## Disease Burden Matrix Analysis

Strategic disease prioritization matrix combines frequency ranking with severity weighting, analyzing `r nrow(register %>% distinct(canonical_disease_imc)) %||% 0` distinct conditions to identify high-burden diseases requiring immediate resource allocation based on case volume and clinical severity.

```{r disease-burden-matrix, fig.cap="Disease burden matrix by region and disease category", fig.width=8, fig.height=5}
# Create robust disease burden analysis with fallbacks
tryCatch({
  # Ensure functions are loaded with error handling
  if (!exists("add_burden_scores") || !exists("plot_disease_burden_matrix")) {
    tryCatch({
      source(here::here("R", "visualization_helpers.R"))
    }, error = function(e) {
      cat("Error loading visualization_helpers.R:", e$message, "\n")
    })
  }
  
  # Ensure severity mapping functions are loaded
  if (!exists("get_severity_mapping") || !exists("severity_weights")) {
    tryCatch({
      source(here::here("R", "disease_categories_taxaware.R"))
    }, error = function(e) {
      cat("Error loading disease_categories_taxaware.R:", e$message, "\n")
    })
  }
  
  # Debug: Check if functions are now available
  cat("Functions available after sourcing:\n")
  cat("- add_burden_scores:", exists("add_burden_scores"), "\n")
  cat("- plot_disease_burden_matrix:", exists("plot_disease_burden_matrix"), "\n")
  cat("- get_severity_mapping:", exists("get_severity_mapping"), "\n")
  cat("- severity_weights:", exists("severity_weights"), "\n")
  
  # Define minimal functions if they're still missing
  if (!exists("get_severity_mapping")) {
    get_severity_mapping <- function() {
      list(
        trauma = list(patterns = c("trauma", "injury", "wound", "fracture", "burn"), weight = 3.0),
        epidemic = list(patterns = c("cholera", "measles", "meningitis", "hepatitis", "typhoid"), weight = 2.5),  
        malnutrition = list(patterns = c("malnutrition", "kwashiorkor", "marasmus", "severe acute"), weight = 2.5),
        respiratory = list(patterns = c("pneumonia", "tuberculosis", "bronchitis"), weight = 2.0),
        diarrheal = list(patterns = c("diarrhea", "gastroenteritis", "dysentery"), weight = 2.0),
        fever = list(patterns = c("malaria", "fever", "sepsis"), weight = 1.8),
        general = list(patterns = c(".*"), weight = 1.0)
      )
    }
  }
  
  if (!exists("severity_weights")) {
    severity_weights <- function() {
      c("Critical" = 3.0, "High" = 2.5, "Moderate" = 2.0, "Standard" = 1.0)
    }
  }
  
  # Override problematic add_burden_scores function with working version
  add_burden_scores <- function(data, morbidity_col = "morbidity", mapping = get_severity_mapping(), top_n = 20) {
    # Helper function to match disease patterns with error handling
    match_severity <- function(disease_name, mapping) {
      tryCatch({
        if (is.null(disease_name) || is.na(disease_name) || disease_name == "") {
          return(1.0)
        }
        disease_lower <- tolower(as.character(disease_name))
        
        if (is.null(mapping) || length(mapping) == 0) {
          return(1.0)
        }
        
        for (category in names(mapping)) {
          if (is.null(mapping[[category]]) || is.null(mapping[[category]]$patterns)) {
            next
          }
          patterns <- mapping[[category]]$patterns
          if (any(sapply(patterns, function(p) {
            tryCatch(grepl(p, disease_lower, ignore.case = TRUE), error = function(e) FALSE)
          }))) {
            weight <- mapping[[category]]$weight
            return(if (is.numeric(weight) && length(weight) > 0) weight else 1.0)
          }
        }
        return(1.0)  # Default weight
      }, error = function(e) {
        cat("Error in match_severity for", disease_name, ":", e$message, "\n")
        return(1.0)
      })
    }
    
    tryCatch({
      cat("Debug: Mapping structure length:", length(mapping), "\n")
      cat("Debug: Data columns:", paste(names(data), collapse = ", "), "\n")
      cat("Debug: Morbidity column:", morbidity_col, "exists:", morbidity_col %in% names(data), "\n")
      
      df_counts <- data %>%
        filter(!is.na(.data[[morbidity_col]])) %>%
        count(.data[[morbidity_col]], name = "n") %>%
        rename(morbidity = !!morbidity_col) %>%
        arrange(desc(n))
      
      cat("Debug: Count data created with", nrow(df_counts), "rows\n")
      
      df_scored <- df_counts %>%
        mutate(
          frequency_rank = row_number(),
          severity = 1.0  # Start with simple default
        ) %>%
        mutate(
          burden_score = n * severity
        )
      
      cat("Debug: Scored data created successfully\n")
      
      if (!is.null(top_n)) df_scored <- slice_head(df_scored, n = top_n)
      return(df_scored)
    }, error = function(e) {
      cat("Error in add_burden_scores:", e$message, "\n")
      # Return minimal fallback
      data.frame(
        morbidity = "Unknown",
        n = 1,
        frequency_rank = 1,
        severity = 1.0,
        burden_score = 1.0
      )
    })
  }
  
  
  # Override plot function to handle the data properly
  plot_disease_burden_matrix <- function(scored_df) {
    # Ensure we have the required columns
    if (!"frequency_rank" %in% names(scored_df)) {
      scored_df$frequency_rank <- seq_len(nrow(scored_df))
    }
    if (!"burden_score" %in% names(scored_df)) {
      scored_df$burden_score <- scored_df$n
    }
    
    # Create a proper severity category for coloring
    scored_df <- scored_df %>%
      mutate(
        severity_category = case_when(
          severity >= 2.5 ~ "High",
          severity >= 2.0 ~ "Medium", 
          TRUE ~ "Standard"
        ),
        # Wrap long disease names
        morbidity_wrapped = stringr::str_wrap(morbidity, 20)
      )
    
    ggplot(scored_df, aes(x = frequency_rank, y = burden_score)) +
      geom_point(aes(color = severity_category, size = n), alpha = 0.7) +
      geom_text(aes(label = morbidity_wrapped), 
                hjust = 0, vjust = 0, size = 2.5, nudge_x = 0.5, nudge_y = 0.1) +
      scale_color_manual(
        values = c("High" = "#d62728", "Medium" = "#ff7f0e", "Standard" = "#1f77b4"),
        name = "Severity"
      ) +
      scale_size_continuous(name = "Count", range = c(2, 6)) +
      labs(
        title = "Disease Burden Matrix",
        subtitle = "Frequency vs. Burden Score Analysis",
        x = "Frequency Rank (1 = Most Common)", 
        y = "Burden Score"
      ) +
      theme_minimal() +
      theme(
        legend.position = "right",
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 12, color = "gray60")
      )
  }
  
  # Now try the sophisticated approach
  if (is.function(get0("add_burden_scores")) && is.function(get0("plot_disease_burden_matrix"))) {
    mapping <- get_severity_mapping()
    
    # Check if standardized_disease column exists
    disease_col <- case_when(
      "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
      "morbidity" %in% names(register) ~ "morbidity",
      "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
      TRUE ~ NA_character_
    )
    
    if (!is.na(disease_col)) {
      scored <- add_burden_scores(register, morbidity_col = disease_col, mapping = mapping, top_n = 20)
      plot_disease_burden_matrix(scored)
    } else {
      stop("No suitable disease column found")
    }
  } else {
    stop("Burden analysis functions not available after loading")
  }
}, error = function(e) {
  cat("Error in disease burden matrix creation:", e$message, "\n")
  cat("Creating fallback burden visualization...\n")
  
  # Fallback: simple burden analysis
  disease_col <- case_when(
    "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
    "morbidity" %in% names(register) ~ "morbidity",
    "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
    TRUE ~ NA_character_
  )
  
  if (!is.na(disease_col)) {
    burden_data <- register %>%
      count(.data[[disease_col]], sort = TRUE) %>%
      slice_head(n = 15) %>%
      mutate(
        frequency_rank = row_number(),
        # Simple severity-based weighting
        severity_weight = case_when(
          grepl("trauma|injury|wound|fracture|burn", .data[[disease_col]], ignore.case = TRUE) ~ 3.0,
          grepl("malnutrition|severe|kwashiorkor|marasmus", .data[[disease_col]], ignore.case = TRUE) ~ 2.5,
          grepl("diarrhea|cholera|measles|meningitis|hepatitis", .data[[disease_col]], ignore.case = TRUE) ~ 2.2,
          grepl("pneumonia|tuberculosis|respiratory", .data[[disease_col]], ignore.case = TRUE) ~ 2.0,
          grepl("malaria|fever|sepsis", .data[[disease_col]], ignore.case = TRUE) ~ 1.8,
          TRUE ~ 1.0
        ),
        burden_score = n * severity_weight,
        severity_category = case_when(
          severity_weight >= 2.5 ~ "Critical",
          severity_weight >= 2.0 ~ "High",
          severity_weight >= 1.5 ~ "Moderate",
          TRUE ~ "Standard"
        )
      )
    
    ggplot(burden_data, aes(x = frequency_rank, y = burden_score)) +
      geom_point(aes(size = n, color = severity_category), alpha = 0.7) +
      geom_text_repel(aes(label = str_wrap(.data[[disease_col]], 20)), 
                      size = 3, max.overlaps = 10) +
      scale_color_manual(
        values = c("Critical" = "#d62728", "High" = "#ff7f0e", "Moderate" = "#2ca02c", "Standard" = "#1f77b4"),
        name = "Severity"
      ) +
      scale_size_continuous(
        labels = comma_format(), 
        range = c(3, 12),
        name = "Cases"
      ) +
      labs(
        title = "Disease Burden Matrix Analysis",
        subtitle = paste("Analysis of", nrow(burden_data), "leading diseases by frequency and severity impact"),
        x = "Frequency Rank (1 = Most Common Disease)",
        y = "Burden Score (Cases × Severity Weight)",
        caption = "Larger points = more cases; Colors indicate severity level"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        plot.title = element_text(face = "bold"),
        plot.subtitle = element_text(color = "gray60")
      ) +
      guides(
        size = guide_legend(override.aes = list(alpha = 1)),
        color = guide_legend(override.aes = list(size = 4, alpha = 1))
      )
  } else {
    ggplot() + 
      annotate("text", x = 0.5, y = 0.5, 
               label = "Disease data not available for burden analysis", 
               size = 4) + 
      theme_void()
  }
})
```

**Key insights:** - **Priority conditions**: Matrix analysis identifies high-frequency, high-severity diseases requiring immediate clinical attention and resource allocation - **Resource allocation**: Top-right quadrant diseases (high burden score) demand enhanced clinical protocols, specialized staff, and supply prioritization\
- **Strategic planning**: Balance common conditions with rare but severe diseases through evidence-based resource allocation and treatment protocols

# Priority Disease Surveillance and Outbreak Prevention

**Early Warning Systems for Epidemic Preparedness**

Epidemic disease surveillance represents a critical component of IMC's public health mandate, providing early warning capabilities essential for protecting vulnerable populations and preventing humanitarian health crises.

## Epidemic-Prone Diseases Monitoring

```{r epidemic-prone-stats, echo=FALSE}
# Calculate epidemic prone statistics safely using available functions
epidemic_cases_count <- if ("epidemic_prone" %in% names(register)) {
  sum(register$epidemic_prone == 1, na.rm = TRUE)
} else if ("epidemic_groups_flag" %in% names(register)) {
  sum(!is.na(register$epidemic_groups_flag), na.rm = TRUE)
} else if ("epidemic_group" %in% names(register)) {
  sum(!is.na(register$epidemic_group), na.rm = TRUE)
} else {
  # Fallback: use standardized epidemic diseases function
  if (exists("get_epidemic_diseases_standardized")) {
    epidemic_diseases_list <- get_epidemic_diseases_standardized()
    epidemic_diseases <- unlist(epidemic_diseases_list, use.names = FALSE)
    disease_col <- if ("canonical_disease_imc" %in% names(register)) "canonical_disease_imc" else "morbidity"
    if (disease_col %in% names(register)) {
      sum(register[[disease_col]] %in% epidemic_diseases, na.rm = TRUE)
    } else { 0 }
  } else { 0 }
}

epidemic_diseases_count <- if ("epidemic_prone" %in% names(register)) {
  length(unique(register$canonical_disease_imc[register$epidemic_prone == 1]))
} else if ("epidemic_groups_flag" %in% names(register)) {
  length(unique(register$canonical_disease_imc[!is.na(register$epidemic_groups_flag)]))
} else if ("epidemic_group" %in% names(register)) {
  length(unique(register$canonical_disease_imc[!is.na(register$epidemic_group)]))
} else {
  # Fallback: count unique epidemic diseases using standardized function
  if (exists("get_epidemic_diseases_standardized")) {
    epidemic_diseases_list <- get_epidemic_diseases_standardized()
    epidemic_diseases <- unlist(epidemic_diseases_list, use.names = FALSE)
    disease_col <- if ("canonical_disease_imc" %in% names(register)) "canonical_disease_imc" else "morbidity"
    if (disease_col %in% names(register)) {
      length(unique(register[[disease_col]][register[[disease_col]] %in% epidemic_diseases]))
    } else { 0 }
  } else { 0 }
}
```

Epidemic surveillance tracks `r fmt_comma(epidemic_cases_count %||% 0)` cases across `r epidemic_diseases_count %||% 0` priority diseases requiring continuous monitoring and rapid response capabilities.

```{r disease-surveillance-analysis, fig.cap="Epidemic Disease Surveillance"}
# Use the comprehensive epidemic surveillance with error handling
tryCatch({
  surveillance_table <- epidemic_surveillance_table(
    register, 
    period_days = 30,
    min_cases = 2
  )
  
  # Display the table if it exists
  if (!is.null(surveillance_table) && nrow(surveillance_table) > 0) {
    print(surveillance_table)
    
    # Generate summary statistics from the surveillance table
    cat("### Key Findings:\n\n")
    cat("- **Total epidemic-prone cases tracked:** ", sum(surveillance_table$recent_30d, na.rm = TRUE), "\n")
    cat("- **Diseases monitored:** ", nrow(surveillance_table), "\n")
    cat("- **Facilities reporting:** ", sum(surveillance_table$facilities, na.rm = TRUE), "\n")
    cat("- **Regions affected:** ", sum(surveillance_table$regions, na.rm = TRUE), "\n\n")
    
    # Show top epidemic concerns
    high_alert <- surveillance_table %>%
      arrange(desc(recent_30d)) %>%
      head(3)
      
    if (nrow(high_alert) > 0) {
      cat("**TOP PRIORITY diseases requiring attention:**\n")
      for (i in 1:nrow(high_alert)) {
        cat("- ", high_alert$Disease[i], ": ", 
            high_alert$recent_30d[i], " recent cases across ",
            high_alert$regions[i], " regions\n")
      }
      cat("\n")
    }
  } else {
    cat("No epidemic-prone diseases detected meeting the minimum case threshold (2+ cases in 30 days).\n\n")
    cat("Current epidemic disease monitoring includes:\n")
    cat("- **Total epidemic-prone cases:** ", epidemic_cases_count, "\n")
    cat("- **Unique epidemic diseases:** ", epidemic_diseases_count, "\n")
  }
}, error = function(e) {
  cat("**Epidemic Disease Surveillance Summary:**\n")
  cat("- **Total epidemic-prone cases:** ", epidemic_cases_count, "\n") 
  cat("- **Unique epidemic diseases:** ", epidemic_diseases_count, "\n")
  cat("\nDetailed surveillance table temporarily unavailable. Basic epidemic monitoring active.\n")
})
```
Table Column Definitions:
-   **Recent (30d):** Number of cases in the last 30 days (based on visit date)\
-   **Facilities:** Number of health facilities reporting cases
-   **Regions:** Number of governorates with cases


```{r epidemic-category-trends, fig.height=8, fig.width=12, fig.cap="Epidemic Disease Category Trends Over Time"}
# Chart 1: Epidemic Disease Category Trends using new taxonomy flags
trend_plot <- plot_epidemic_category_trends(register, period_days = 90)
print(trend_plot)
```

```{r priority-disease-alerts, fig.height=6, fig.width=10, fig.cap="Priority Disease Alert Dashboard"}
# Chart 2: Priority Disease Alert Dashboard using taxonomy flags
alert_plot <- plot_priority_disease_alerts(register, period_days = 30)
print(alert_plot)
```

Alert Level Definitions:

-   **🔴 HIGH:** Immediate investigation and response required
-   **🟠 MEDIUM:** Enhanced surveillance and preparedness needed\
-   **🟡 LOW:** Routine monitoring with periodic review
-   **⚪ NONE:** Below alert thresholds


## Syndromic Surveillance Trends

This line chart tracks syndromic groups (diseases with similar symptoms) over the past 12 months. Syndromic surveillance helps detect outbreaks before laboratory confirmation and can identify unusual patterns in symptom-based disease categories.

**Key insights:** - **Alert status**: Continuous monitoring of epidemic-prone diseases with established alert thresholds and rapid response protocols - **Case distribution**: Focus enhanced surveillance on high-burden epidemic conditions showing unusual patterns or increased incidence - **Response readiness**: Verify line-lists, notify focal points, and ensure stock availability (ORS, antibiotics, PPE) for priority epidemic conditions

Syndromic early warning: 12-month view highlights `r summary_vars$syndrome_of_interest %||% "—"` with `r summary_vars$syndrome_recent_change_dir %||% "—"` `r abs(summary_vars$syndrome_recent_change_pct %||% NA)`%. Action: intensify community case-finding and IPC where elevated.

```{r syndromic-surveillance, fig.cap="Syndromic surveillance trends for epidemic-prone diseases"}
# Ensure required functions are available
if (!exists("get_syndromic_groups")) {
  source(here::here("R", "disease_categories_taxaware.R"), local = TRUE)
}

# Use enhanced syndromic surveillance plotting with robust fallback handling
tryCatch({
  plot_syndromic_surveillance(register, period_col = "month2", window_days = 365)
}, error = function(e) {
  cat("Syndromic surveillance chart error:", e$message, "\n")
  
  # Create a simple diagnostic plot
  ggplot2::ggplot() +
    ggplot2::annotate("text", x = 0.5, y = 0.5, 
                      label = paste("Syndromic surveillance data not available\n",
                                    "Error:", e$message),
                      size = 4, hjust = 0.5, vjust = 0.5) +
    ggplot2::theme_void() +
    ggplot2::labs(title = "Syndromic Surveillance Trends",
                  subtitle = "Data processing issue - please check data and function availability")
})
```

# Malnutrition Surveillance and Nutritional Health

Malnutrition surveillance identifies `r fmt_comma(sum(register$malnutrition_related == 1, na.rm = TRUE) %||% 0)` cases representing `r fmt_pct1((sum(register$malnutrition_related == 1, na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% of consultations, with severe malnutrition cases affecting vulnerable children requiring immediate intervention.

```{r malnutrition-trends-enhanced, echo = FALSE, fig.cap="Enhanced malnutrition case trends by type and demographics", fig.height=8}
plot_malnutrition_demographics_enhanced(register)
```

### Malnutrition Caseload Summary

```{r malnutrition-caseload-summary, results='asis', echo=FALSE}
display_malnutrition_summary(malnutrition_summary, summary_vars)
```

**Key insights:** - **Case burden**: `r fmt_comma(sum(register$malnutrition_related == 1, na.rm = TRUE) %||% 0)` malnutrition cases tracked (`r fmt_pct1((sum(register$malnutrition_related == 1, na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% of total consultations) - **Severe cases**: Critical malnutrition cases demand immediate therapeutic feeding programs and specialized nutritional protocols - **Geographic priority**: Focus enhanced nutrition programming on regions with highest malnutrition burden and vulnerable populations

# Trauma Surveillance and Conflict-Related Health Impact

Trauma surveillance documents `r fmt_comma(sum(register$trauma_related == 1, na.rm = TRUE) %||% 0)` cases representing `r fmt_pct1((sum(register$trauma_related == 1, na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% of consultations, indicating conflict impact patterns requiring emergency medical preparedness.

```{r trauma-analysis, fig.cap="Distribution of trauma vs non-trauma cases by governorate", fig.height=8, fig.width=12}
# Check if trauma_summary has data for plotting
if (!is.null(trauma_summary$summary) && nrow(trauma_summary$summary) > 0) {
  plot_trauma_distribution(trauma_summary$summary)
} else {
  # Create a simple message plot when no trauma data is available
  ggplot(data.frame(x = 1, y = 1, label = "No trauma data available for visualization"), 
         aes(x = x, y = y)) +
    geom_text(aes(label = label), size = 6, color = "gray60") +
    theme_void() +
    labs(title = "Trauma Distribution", 
         subtitle = "No trauma cases detected in the dataset")
}

```

**Key insights:** - **Trauma burden**: `r fmt_comma(sum(register$trauma_related == 1, na.rm = TRUE) %||% 0)` trauma cases tracked (`r fmt_pct1((sum(register$trauma_related == 1, na.rm = TRUE) / nrow(register)) * 100 %||% 0)`% of total consultations) - **Geographic concentration**: Focus trauma preparedness on regions showing elevated conflict-related injury patterns and emergency needs - **Operational readiness**: Ensure trauma kits, referral protocols, and blood bank availability in high-burden facilities

# Health System Performance and Service Delivery Analysis

**Optimizing Health Service Delivery Through Data-Driven Insights**

Health system performance analysis provides essential intelligence for operational efficiency, strategic planning, and donor accountability. This comprehensive assessment evaluates service delivery patterns, resource utilization, and system capacity.

## Facility Type Distribution Analysis

Health service delivery shows `r fmt_pct1(summary_vars$primary_care_share %||% 0)`% primary care consultations and `r fmt_pct1(summary_vars$hospital_share %||% 0)`% hospital-level care, indicating facility load distribution requiring referral pathway optimization.

```{r facility-distribution, fig.cap="Distribution of consultations by facility type"}
if (all(c("facility_type", "admin1") %in% colnames(register))) {
  facility_chart <- create_facility_type_distribution_chart(register)
  facility_chart
} else {
  cat("Facility type or governorate information not available in the dataset.")
}
```

**Key insights:** - **Service mix**: Primary health centers handle `r fmt_pct1(summary_vars$primary_care_share %||% 0)`% of consultations with hospitals managing `r fmt_pct1(summary_vars$hospital_share %||% 0)`% - **Load balancing**: `r summary_vars$overloaded_facilities %||% 0` facilities exceed capacity thresholds requiring workload redistribution - **Referral optimization**: Review appropriateness of hospital referrals to ensure efficient resource utilization across facility levels

## Health System Performance Dashboard

Health system monitoring reveals `r summary_vars$facilities_increase_dir %||% "stable"` `r abs(summary_vars$facilities_increase_pct %||% 0)`% facility volume changes with `r summary_vars$regions_access_improved %||% 0` regions showing improved access patterns requiring targeted optimization strategies.

```{r health-system-performance, fig.cap="Health system performance metrics"}

if ("orgunit" %in% colnames(register)) {
  performance_charts <- create_health_system_performance_charts(register)
  performance_charts
} else {
  cat("Organization unit information not available for performance analysis.")
}
```

**Key insights:** - **Facility performance**: `r abs(summary_vars$facilities_increase_pct %||% 0)`% of facilities show `r summary_vars$facilities_increase_dir %||% "stable"` consultation volumes requiring performance review - **Access improvements**: `r summary_vars$regions_access_improved %||% 0` regions demonstrate enhanced health service accessibility - **System optimization**: Focus supportive supervision on low performers while scaling successful practices from high-performing facilities

## Facility Burden by Disease Severity

This chart analyzes healthcare burden across facilities based on disease severity distribution, showing how critical cases (trauma), epidemic risks, chronic care needs, and standard primary care are distributed across the health system.

```{r facility-burden-severity, fig.height=8, fig.width=12, fig.cap="Facility Burden by Disease Severity Distribution"}
# Chart 1: Facility burden by disease severity
severity_plot <- plot_facility_burden_severity(register, admin_level = "facility", period_days = 60)
print(severity_plot)
```

## High-Risk Groups Consultation Burden

Vulnerable population analysis reveals high-risk groups (under-5, pregnant women, trauma, malnutrition) account for `r fmt_pct1(summary_vars$high_risk_share %||% 0)`% of consultations, requiring specialized care protocols and resource allocation optimization.

```{r high-risk-groups-burden, fig.height=6, fig.width=10, fig.cap="High-Risk Groups Healthcare Utilization"}
# Chart 2: High-risk groups consultation burden
cat("🔍 Debug: Creating high-risk groups chart...\n")
cat("Register dimensions:", nrow(register), "rows x", ncol(register), "columns\n")

# Check if the function exists
if (exists("plot_high_risk_groups_burden")) {
  cat("✅ plot_high_risk_groups_burden function exists\n")
  
  tryCatch({
    risk_groups_plot <- plot_high_risk_groups_burden(register, period_days = 30)
    
    if (is.null(risk_groups_plot)) {
      cat("❌ Chart function returned NULL\n")
      # Create a fallback plot
      risk_groups_plot <- ggplot() + 
        annotate("text", x = 0.5, y = 0.5, label = "High-risk groups chart data not available", 
                size = 4, hjust = 0.5, vjust = 0.5) + 
        theme_void() +
        labs(title = "High-Risk Groups Consultation Burden", 
             subtitle = "Data processing in progress")
    } else {
      cat("✅ Chart created successfully\n")
    }
    
    print(risk_groups_plot)
    
  }, error = function(e) {
    cat("❌ Error creating high-risk groups chart:", e$message, "\n")
    # Create error fallback plot  
    error_plot <- ggplot() + 
      annotate("text", x = 0.5, y = 0.5, 
               label = paste("Chart error:", substr(e$message, 1, 50)), 
               size = 4, hjust = 0.5, vjust = 0.5) + 
      theme_void() +
      labs(title = "High-Risk Groups Consultation Burden", 
           subtitle = "Error in chart generation")
    print(error_plot)
  })
  
} else {
  cat("❌ plot_high_risk_groups_burden function not found\n")
  # Create function-missing fallback plot
  missing_plot <- ggplot() + 
    annotate("text", x = 0.5, y = 0.5, 
             label = "High-risk groups chart function not loaded", 
             size = 4, hjust = 0.5, vjust = 0.5) + 
    theme_void() +
    labs(title = "High-Risk Groups Consultation Burden", 
         subtitle = "Function not available")
  print(missing_plot)
}
```

**Key insights:** - **Vulnerable burden**: High-risk groups represent `r fmt_pct1(summary_vars$high_risk_share %||% 0)`% of total consultations requiring specialized protocols - **Resource alignment**: Under-5 (`r fmt_pct1(summary_vars$under5_percentage %||% 0)`%) and maternal health cases demand pediatric and obstetric commodities - **Capacity planning**: Trauma and malnutrition cases require immediate specialized care pathways and emergency preparedness

# Geographic Insights

```{r geospatial-setup, include=FALSE}
# Setup geospatial environment with error handling
shapefiles <- tryCatch({
  setup_geospatial_environment()
}, error = function(e) {
  cat("Geospatial shapefiles not available:", e$message, "\n")
  NULL
})
```

## Geographic Summary Statistics

Geographic health metrics show `r length(unique(register$admin1[!is.na(register$admin1)])) %||% 0` governorates with `r fmt_comma(length(unique(register$orgunit[!is.na(register$orgunit)])) %||% 0)` facilities, revealing health service distribution patterns requiring strategic resource allocation and emergency preparedness.

```{r geo-summary-table}
# Create geographic summary table with error handling
tryCatch({
  summary_table <- create_geographic_summary_table(register)
  print(summary_table)
}, error = function(e) {
  # Fallback: create basic geographic summary
  if ("admin1" %in% names(register) && "orgunit" %in% names(register)) {
    geo_summary <- register %>%
      group_by(admin1) %>%
      summarise(
        Consultations = n(),
        Facilities = n_distinct(orgunit, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      arrange(desc(Consultations))
    
    print(kable(geo_summary, 
                col.names = c("Governorate", "Consultations", "Facilities"),
                format.args = list(big.mark = ",")))
  } else {
    cat("Geographic data columns not available for detailed summary.")
  }
})
```

**Key insights:** - **Geographic coverage**: Health services span `r length(unique(register$admin1[!is.na(register$admin1)])) %||% 0` governorates with `r fmt_comma(length(unique(register$orgunit[!is.na(register$orgunit)])) %||% 0)` active facilities - **Utilization patterns**: Regional analysis reveals varied facility utilization requiring targeted resource allocation optimization - **Health priorities**: Focus emergency medical supplies and specialized care on areas showing elevated trauma and epidemic disease burden

## Governorate-Level Analysis {.tabset}

### Consultation Volume Choropleth

Geographic consultation mapping reveals `r summary_vars$map_peak_region %||% "key regions"` with highest density, while top-3 governorates account for `r fmt_pct1(summary_vars$map_top3_share %||% 0)`% of visits, indicating access equity optimization opportunities.

```{r governorate-choropleth, fig.cap="Number of consultations by governorate showing geographic distribution of health service utilization", fig.height=8, fig.width=10}
# Create choropleth map with fallback
tryCatch({
  if (!is.null(shapefiles) && !is.null(shapefiles$admin1)) {
    consultation_map <- create_consultation_choropleth(
      data = register,
      shapefile = shapefiles$admin1
    )
    print(consultation_map)
  } else {
    # Fallback: create bar chart if no shapefiles available
    if ("admin1" %in% names(register)) {
      geo_data <- register %>%
        count(admin1, name = "consultations") %>%
        arrange(desc(consultations)) %>%
        head(10)
      
      ggplot(geo_data, aes(x = reorder(admin1, consultations), y = consultations)) +
        geom_col(fill = "#1f77b4", alpha = 0.8) +
        coord_flip() +
        labs(
          title = "Consultation Volume by Governorate",
          x = "Governorate", 
          y = "Number of Consultations"
        ) +
        theme_minimal() +
        scale_y_continuous(labels = comma_format())
    } else {
      cat("Geographic data not available for visualization")
    }
  }
}, error = function(e) {
  cat("Geographic visualization error:", e$message, "\n")
  cat("Choropleth mapping temporarily unavailable.")
})
```

### Facility Type Distribution

This map shows the distribution of different health facility types across governorates using donut charts positioned at each region's center.

```{r facility-donut-map, fig.cap="Distribution of health facility types by governorate using donut charts", fig.height=8, fig.width=12}
if ("facility_type" %in% colnames(register)) {
  facility_map <- create_facility_distribution_map(
    data = register,
    shapefile = shapefiles$admin1,
    facility_col = "orgunit",
    facility_type_col = "facility_type",
    year_col = "year"
  )
  facility_map
} else {
  cat("Facility type data not available for visualization.")
}
```

## District-Level Analysis

More granular analysis of consultation density at district level.

```{r district-heatmap, fig.cap="Consultation density heatmap at district level showing detailed geographic patterns", fig.height=8, fig.width=12}
tryCatch({
  if ("admin2" %in% colnames(register) && !is.null(shapefiles) && !is.null(shapefiles$admin2)) {
    district_map <- create_district_heatmap(
      data = register,
      shapefile = shapefiles$admin2
    )
    print(district_map)
  } else {
    cat("District-level administrative data (admin2) not available for detailed mapping.")
  }
}, error = function(e) {
  cat("District heatmap error:", e$message, "\n")
  cat("District-level visualization temporarily unavailable.")
})
```

## Disease-Specific Geographic Patterns

This panel of small multiple maps shows the geographic distribution of the top 6 disease categories across governorates. Each map uses red color intensity to show case counts, helping identify regional disease patterns and potential geographic clustering of specific health conditions.

```{r disease-geography, fig.cap="Geographic distribution of priority disease categories", fig.height=10, fig.width=12}
tryCatch({
  if ("canonical_disease_imc" %in% colnames(register) && !is.null(shapefiles) && !is.null(shapefiles$admin1)) {
    disease_maps <- create_disease_geography_maps(
      data = register,
      shapefile = shapefiles$admin1
  )
  
  # Combine maps using patchwork if available
  if (requireNamespace("patchwork", quietly = TRUE)) {
    library(patchwork)
    patchwork::wrap_plots(disease_maps, ncol = 3) +
      patchwork::plot_annotation(
        title = "Geographic Distribution of Top Disease Categories",
        subtitle = paste("Data for", max(register$year, na.rm = TRUE)),
        theme = theme(
          plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
          plot.subtitle = element_text(size = 12, hjust = 0.5)
        )
      )
    } else {
      # Show first disease map only
      disease_maps[[1]] +
        labs(
          title = "Geographic Distribution of Top Disease Category",
          subtitle = "Install \'patchwork\' package to see all disease maps"
        )
    }
  } else {
    cat("Disease category data not available for geographic mapping.")
  }
}, error = function(e) {
  cat("Disease geography mapping error:", e$message, "\n")
  cat("Disease-specific geographic visualization temporarily unavailable.")
})
```

## Trauma Case Geographic Analysis

This choropleth map shows trauma cases as a percentage of total consultations by governorate, helping identify regions with higher trauma burden. Areas with higher trauma percentages (shown in red) may indicate conflict-affected areas, accident-prone regions, or areas requiring enhanced emergency medical services.

Trauma intensity: `r summary_vars$trauma_hotspot_region %||% "—"` shows `r fmt_pct1(summary_vars$trauma_hotspot_pct %||% NA)`% trauma share. Action: bolster ER readiness and referral pathways.

```{r trauma-geography, fig.cap="Geographic distribution of trauma cases showing conflict-affected areas", fig.height=8, fig.width=10}
tryCatch({
  if ("type_case" %in% colnames(register) && !is.null(shapefiles) && !is.null(shapefiles$admin1)) {
    trauma_map <- create_trauma_geography_map(
      data = register,
      shapefile = shapefiles$admin1
    )
    print(trauma_map)
  } else if ("trauma_related" %in% colnames(register) && "admin1" %in% colnames(register)) {
    # Fallback: create basic trauma visualization
    trauma_data <- register %>%
      group_by(admin1) %>%
      summarise(
        total_cases = n(),
        trauma_cases = sum(trauma_related == 1, na.rm = TRUE),
        trauma_pct = (trauma_cases / total_cases) * 100,
        .groups = "drop"
      ) %>%
      filter(trauma_cases > 0) %>%
      arrange(desc(trauma_pct))
    
    if (nrow(trauma_data) > 0) {
      ggplot(trauma_data, aes(x = reorder(admin1, trauma_pct), y = trauma_pct)) +
        geom_col(fill = "red", alpha = 0.7) +
        coord_flip() +
        labs(
          title = "Trauma Cases as % of Total Consultations by Governorate",
          x = "Governorate",
          y = "Trauma Percentage (%)"
        ) +
        theme_minimal()
    } else {
      cat("No trauma cases found in the data.")
    }
  } else {
    cat("Trauma case data (type_case or trauma_related) not available.")
  }
}, error = function(e) {
  cat("Trauma geography mapping error:", e$message, "\n")
  cat("Trauma geographic visualization temporarily unavailable.")
})
```

```{r ai-conclusions-check, include=FALSE}
show_ai_section <- isTRUE(params$enable_ai) && isTRUE(ai_system$available)
```

`r if(show_ai_section) '# Enhanced AI Analysis and Strategic Recommendations' else ''`

`r if(show_ai_section) '**Advanced Epidemiological Intelligence for Strategic Decision Making**' else ''`

`r if(show_ai_section) 'This section presents AI-enhanced analysis using advanced epidemiological models to extract deeper insights from surveillance data. These analyses complement standard epidemiological methods with pattern recognition, predictive modeling, and comprehensive risk assessment.' else ''`

```{r generate-ai-summaries, results='asis', echo=FALSE, include = FALSE}
# Safe AI summary generation
# ai_summaries <- list()  # Don't reset - use summaries already generated earlier

if (isTRUE(ai_system$available) && !isFALSE(ai_system$enhanced)) {
  cat("🤖 Checking AI summaries...\n")
  
  # Only regenerate if summaries don't exist or are empty
  if (is.null(ai_summaries) || length(ai_summaries) == 0) {
    cat("🤖 Generating AI summaries...\n")
    tryCatch({
      if (exists("generate_all_ai_summaries")) {
        ai_summaries <- generate_all_ai_summaries(register, ai_system)
      
      if ("error" %in% names(ai_summaries)) {
        cat("⚠️ AI analysis partially failed:", ai_summaries$error, "\n")
        } else {
          cat("✅ AI summaries generated:", paste(names(ai_summaries), collapse = ", "), "\n")
        }
      } else {
        cat("⚠️ AI summary function not available\n")
      }
      
    }, error = function(e) {
      cat("❌ AI summary generation failed:", e$message, "\n")
      ai_summaries$error <- paste("Generation failed:", e$message)
    })
  } else {
    cat("✅ Using existing AI summaries:", paste(names(ai_summaries), collapse = ", "), "\n")
  }
  
} else {
  cat("📊 Using standard analysis methods\n")
  
  # Create basic fallback summaries
  ai_summaries <- list(
    monthly_summary = paste(
      "Standard epidemiological analysis of", format(total_consultations, big.mark = ","), 
      "consultations across", total_facilities, "facilities.",
      "Data quality score:", summary_vars$quality_score, "/100.",
      "Enhanced AI analysis not available."
    ),
    geographic_insights = paste(
      "Geographic analysis covers", geographic_coverage, "administrative regions.",
      "Standard statistical methods applied for geographic pattern analysis."
    ),
    demographic_insights = paste(
      "Demographic analysis shows", pediatric_percentage, "% pediatric cases and",
      female_percentage, "% female patients. Standard demographic analysis methods applied."
    ),
    analysis_quality = 75
  )
}

cat("📋 Analysis summaries prepared\n")
```

```{r ai-disease-trends, results='asis', echo=FALSE}
# Debug: Check AI disease trends section (only in dev mode)
if (isTRUE(params$debug) || isTRUE(getOption("epidashboard.debug", FALSE))) {
  cat("🔍 Disease Trends Debug:\n")
  cat("   - params$enable_ai:", as.character(params$enable_ai %||% "NULL"), "\n")
  cat("   - ai_system$available:", isTRUE(ai_system$available), "\n")
  cat("   - ai_summaries exists:", !is.null(ai_summaries), "\n")
  cat("   - ai_summaries length:", length(ai_summaries), "\n")
  if (length(ai_summaries) > 0) {
    cat("   - ai_summaries names:", paste(names(ai_summaries), collapse = ", "), "\n")
  }
}

# Only show AI analysis if enabled and summaries are available
if (isTRUE(params$enable_ai) && isTRUE(ai_system$available) &&
    !is.null(ai_summaries) && length(ai_summaries) > 0) {

  cat("## Advanced Disease Pattern Analysis\n\n")
  cat("**AI-Enhanced Epidemiological Intelligence")
  
  # Show deployment context
  if (!is.null(ai_system$deployment_type) && ai_system$deployment_type != "general") {
    deployment_type <- ai_system$deployment_type
    context_info <- switch(deployment_type,
      "refugee_camp" = " - Refugee Camp Context",
      "urban_clinic" = " - Urban Clinic Context",
      "rural_health" = " - Rural Health Context", 
      "emergency_response" = " - Emergency Response Context",
      ""
    )
    cat(context_info)
  }
  cat("**\n\n")
  
  cat("The following insights are generated using context-aware AI analysis of disease patterns, incorporating machine learning models trained on epidemiological principles and humanitarian health contexts")
  
  # Add context-specific note
  if (!is.null(ai_system$user_customization)) {
    cat(", specifically customized for ", tolower(ai_system$user_customization$context$setting_description %||% "this deployment"), "")
  }
  cat(":\n\n")

  # Show comprehensive AI analysis sections
  
  # 1. Geographic Intelligence
  if (!is.null(ai_summaries$geographic_insights) && nzchar(ai_summaries$geographic_insights) && 
      !grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$geographic_insights)) {
    cat("### Geographic Intelligence\n\n")
    cat(ai_summaries$geographic_insights, "\n\n")
  }
  
  # 2. Demographic Intelligence
  if (!is.null(ai_summaries$demographic_insights) && nzchar(ai_summaries$demographic_insights) && 
      !grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$demographic_insights)) {
    cat("### Demographic Intelligence\n\n")
    cat(ai_summaries$demographic_insights, "\n\n")
  }
  
  # 3. Disease-Specific Narratives
  if (!is.null(ai_summaries$disease_narratives) && length(ai_summaries$disease_narratives) > 0) {
    for (disease in names(ai_summaries$disease_narratives)) {
      narrative <- ai_summaries$disease_narratives[[disease]] %||% ""
      if (nzchar(narrative) && !grepl("(?i)(incomplete|error|not available|failed)", narrative)) {
        cat("### ", disease, " Pattern Analysis\n\n", narrative, "\n\n", sep = "")
      }
    }
  }
  
  # 4. Risk Assessment
  if (!is.null(ai_summaries$risk_assessment) && nzchar(ai_summaries$risk_assessment) && 
      !grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$risk_assessment)) {
    cat("### Risk Assessment Intelligence\n\n")
    cat(ai_summaries$risk_assessment, "\n\n")
  }
  
  # 5. Facility Performance Intelligence
  if (!is.null(ai_summaries$facility_performance) && nzchar(ai_summaries$facility_performance) && 
      !grepl("(?i)(incomplete|error|not available|failed)", ai_summaries$facility_performance)) {
    cat("### Healthcare Facility Intelligence\n\n")
    cat(ai_summaries$facility_performance, "\n\n")
  }

} else {
  # ---------- Fallback (standard) trend analysis ----------
  cat("## 📈 Disease Trend Analysis\n\n")
  cat("<div class='standard-analysis'>\n")
  cat("**Standard Epidemiological Analysis**\n\n")
  cat("Using evidence-based statistical methods for comprehensive trend analysis:\n\n")

  # Pick a disease column we have
  disease_col <- dplyr::case_when(
    "canonical_disease_imc" %in% names(register) ~ "canonical_disease_imc",
    "category_canonical_disease_imc" %in% names(register) ~ "category_canonical_disease_imc",
    "morbidity" %in% names(register) ~ "morbidity",
    TRUE ~ NA_character_
  )

  if (!is.na(disease_col) && "datevisit" %in% names(register)) {
    # Top 3 diseases by count
    top3 <- register |>
      dplyr::count(.data[[disease_col]], sort = TRUE) |>
      dplyr::slice_head(n = 3) |>
      dplyr::pull(1)

    for (disease in top3) {
      cat("### ", disease, "\n\n", sep = "")
      disease_trend <- register |>
        dplyr::filter(.data[[disease_col]] == disease) |>
        dplyr::mutate(week = lubridate::floor_date(.data[["datevisit"]], "week")) |>
        dplyr::count(week) |>
        dplyr::arrange(week) |>
        dplyr::filter(!is.na(week)) |>
        dplyr::slice_tail(n = 12)

      if (nrow(disease_trend) >= 4) {
        recent_avg  <- mean(tail(disease_trend$n, 4))
        earlier_avg <- mean(head(disease_trend$n, min(8, nrow(disease_trend) - 4)))
        trend_ratio <- if (earlier_avg > 0) recent_avg / earlier_avg else NA_real_

        trend_direction <- dplyr::case_when(
          is.na(trend_ratio)        ~ "insufficient baseline",
          trend_ratio > 1.5         ~ "increasing significantly",
          trend_ratio > 1.2         ~ "increasing moderately",
          trend_ratio < 0.8         ~ "decreasing significantly",
          trend_ratio < 0.9         ~ "decreasing moderately",
          TRUE                      ~ "stable"
        )

        cat("**Trend Assessment:** ", trend_direction,
            if (!is.na(trend_ratio)) paste0(" (", round(trend_ratio, 2), "x)") else "", "\n", sep = "")
        cat("**Recent average:** ", round(recent_avg, 1), " cases/week\n", sep = "")
        cat("**Baseline average:** ", round(earlier_avg, 1), " cases/week\n", sep = "")

        if (!is.na(trend_ratio)) {
          if (trend_ratio > 1.5) {
            cat("**Surveillance Priority:** 🔴 High - investigate trend drivers\n")
          } else if (trend_ratio > 1.2) {
            cat("**Surveillance Priority:** 🟡 Medium - monitor closely\n")
          } else {
            cat("**Surveillance Priority:** 🟢 Routine - continue standard monitoring\n")
          }
        } else {
          cat("**Surveillance Priority:** ⚪ Not rated (insufficient baseline)\n")
        }
      } else {
        cat("**Status:** Insufficient data for trend analysis (requires minimum 4 weeks)\n")
      }
      cat("\n")
    }
  } else {
    cat("_Disease or date columns not available for trend analysis._\n\n")
  }

  cat("*Standard statistical trend analysis. Enhanced AI analysis not available or returned no narratives.*\n")
  cat("</div>\n\n")
}
```

------------------------------------------------------------------------

# Technical Notes

## Data Sources and Methods

-   **Data Source**: IMC DHIS2 Health Information System Patient Register
-   **Reporting Period**: `r format(validation_results$date_range[1], "%B %Y")` to `r format(validation_results$date_range[2], "%B %Y")`
-   **Analysis Date**: `r Sys.Date()`
-   **Total Records**: `r comma(validation_results$total_rows)`
-   **Statistical Methods**: Trend analysis using 8-week baseline comparison; Alert detection using 2.0x threshold for outbreak signals; Quality scoring using weighted completeness metrics - Geographic analysis across `r geographic_coverage` administrative regions.

## AI System Information
```{r ai-notice, results='asis', echo=FALSE}
if (isTRUE(params$enable_ai) && isTRUE(ai_system$available)) {
  cat("- **Model**: ", ai_system$model %||% "Not specified", " (Local deployment for privacy)\n")
  cat("- **Analysis Confidence**: ", round(ai_summaries$analysis_quality %||% 0, 1), "% overall confidence level\n")
  cat("- **Expert Review Items**: ", sum(sapply(names(ai_summaries), function(x) paste0(x, "_review_flag") %in% names(ai_summaries))), " items flagged for expert validation\n")
  cat("- **Privacy Compliance**: ✅ All processing performed locally without external data transmission\n\n")
  
  # Display customization context if available
  if (!is.null(ai_system$user_customization)) {
    custom <- ai_system$user_customization
    cat("**Deployment Context Configuration:**\n\n")
    cat("- **Context**: ", custom$context$context_name %||% "default", "\n")
    cat("- **Setting**: ", custom$context$setting_description %||% "not specified", "\n")
    cat("- **Population**: ", custom$context$population_description %||% "not specified", "\n")
    cat("- **Deployment Type**: ", ai_system$deployment_type %||% "general", " (context-aware AI responses)\n")
    cat("- **Alert Threshold**: ", custom$thresholds$outbreak_multiplier %||% 2.0, "x baseline for outbreak detection\n")
    cat("- **Priority Diseases**: ", paste(custom$diseases$endemic_diseases %||% "not specified", collapse = ", "), "\n\n")
    
    cat("*AI analysis is customized for this deployment context with appropriate alert thresholds, population priorities, and operational constraints.*\n\n")
  }
  
  cat("*This report includes AI-generated insights using advanced epidemiological analysis models. All AI outputs undergo quality validation and are flagged for expert review when appropriate. Professional epidemiological oversight is recommended for all AI-generated recommendations.*\n\n")
} else if (isTRUE(params$enable_ai) && !isTRUE(ai_system$available)) {
  cat("## Analysis Methods\n\n")
  cat("*This report uses standard statistical analysis methods for epidemiological surveillance. AI enhancement was enabled but not available during report generation.*\n\n")
}
```

## Data Protection and Privacy Compliance

-   **Data Anonymization**: All health data has been anonymized and aggregated to protect patient privacy
-   **No Personal Information**: No personally identifiable information is included in this analysis
-   **Secure Processing**: `r if(isTRUE(params$enable_ai) && isTRUE(ai_system$available)) "AI processing is performed entirely on local systems without external data transmission" else "All data processing follows secure protocols with no external transmission"`
-   **Access Controls**: Report access is limited to authorized personnel for program management and donor reporting

------------------------------------------------------------------------
